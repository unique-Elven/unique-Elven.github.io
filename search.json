[{"title":"PWN基础知识","url":"/2022/09/24/pwn 01/","content":"\n# 一.什么是溢出？\n1.概念：在计算机中，当要表示的数据超出计算机所使用的数据的表示范围时，则产生数据溢出\n\n2.产生的原因：\n  *使用非安全类型（non -type-safe)的语言如C/C++等\n  *以不可靠的方式存取或者复制内存缓冲区\n  *编译器设置的内存缓冲区太靠近关键数据结构；\n\n# 二.什么是PWN？\n概念：\n          在计算机中，当要表示的数据超出计算机所使用的数据表示范围时，则产生数据的溢出。\n        “pwn\"是一个黑客语法的俚语词，是指攻破设备或者系统。发音类似“砰”，对于黑客而言，这就是成功实施黑客攻击的声音----砰的一声，被“黑”的电脑或手机就被操控。\n\n# 三.复习寄存器\nESP: 用来储存函数调用得的栈顶指针，在压栈和退栈时发生变化\nEBP: 用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置\nEIP: 用来储存即将执行的程序指令的地址\n\n# 四.复习汇编\n  *32位x86架构下汇编指令有两种格式intel与AT&T\n  *Intel：寄存器名称和数值前无符号     AT&T：寄存器名称前加”%“，数值前加”$\"\n  *在.gdbinit配置文件中可以配置：set disassembly-flavor intel\n\n# 五.栈帧\n栈帧就是一个函数执行的环境：函数参数、局部变量、函数执行后返回到哪里等等。每一个栈帧代表的就是一个未执行完的函数\n\n        ps: [ebp - xx]一般都是局部变量\n            [ebp + xx]一般都是参数\n\n# 六.分析函数执行时堆栈变化\n## 1. 在linux的控制台编译C文件\n要求：熟悉Linux常用命令和Vi编辑器\n\n首先进入root用户模式 sudo su：\n![图片](./pwn/pwn1.png)\nls 命令 显示文件目录：\n![图片](./pwn/pwn2.png)\n命令cd  切换到指定目录：\n```Linux\n                      cd 桌面\n```\n命令mkdir 创建目录：\n```Linux\n                      mkdir PWN\n```\n命令chmod 修改文件或目录权限：\n```Linux\n                    chmod 777             //最高权限\n```\n命令touch 创建相关文件：\n```Linux\ntouch heilo.c\n```\n进入Vi编辑器打开文本：\n```Linux\nvi hello.c\n```\n之后按下 i 才能进行编辑，输入以下代码：\n```C\n#include<stdio.h>\n\nint test(int a,int b)\n{\n        int c=a+b;\n        return c;\n}\n\nint main()\n{\n        int d=test(1,2);\n        return 0;\n}\n```\n\n然后按Esc后输入 :wq 才能保存并且退出！\n\n命令gcc 编译.c文件：\n```Linux\n\ngcc -m32 -o hello hello.c\n```\n\n## 2. 运行gdb\n```Linux\ngdb hello \n```\n![图片](./pwn/pwn3.png)\n\n```Linux\ndisass main          反汇编查看main函数\n```\n![图片](./pwn/pwn4.png)\n\n```Linux\ndisass test                                                           查看test函数\n```\n![图片](./pwn/pwn5.png)\n\n```Linux\nb *0x565554ed                                          加断点 \n```\n![图片](./pwn/pwn6.png)\n\n```Linux\nrun                                                              运行\nr是运行\nn是单步执行，next遇到函数不会进入函数内部\nsi是步入，step会执行到函数内部c是继续运行，调试时，使用continue命令继续执行程序。程序遇到断电后再次暂停执行；\n如果没有断点，就会一直执行到结束\n```\n![图片](./pwn/pwn7.png)\n这里即使到了我们的断点。\n\n然后按 n 单步执行，注意观察堆栈变化：\npush ebp就是把寄存器ebp的值，也就是ebp的地址压入堆栈中\n![图片](./pwn/pwn8.png)\n\nmov ebp，esp就是把esp的地址传给epd，因ebp会上移动到esp所在的位置\n![图片](./pwn/pwn9.png)\n\nsub esp，0x10就是把esp的地址减去了16字节，外观上看就是把esp上移了4行\n![图片](./pwn/pwn10.png)\n\ncall   __x86.get_pc_thunk.ax   这个就先不管啦\nadd    eax, 0x1ae4 也是先不管\n\nmov    edx, dword ptr [ebp + 8] 这个其实就是esp寻址，把参数1放到edx\nmov    eax, dword ptr [ebp + 0xc]   这个其实也是，把参数2放到eax\n此时看的该是寄存器：\n![图片](./pwn/pwn11.png)\n\nadd    eax, edx       把edx的值和eax相加后保存到eax\n![图片](./pwn/pwn12.png)\n\n此时堆栈都还没发生变化，主要是在实现函数的主要功能\n\nmov    dword ptr [ebp - 4], eax    就是把eax存储的最后计算结果转存到堆栈中\n![图片](./pwn/pwn13.png)\n\nmov    eax, dword ptr [ebp - 4]   又把计算结果返回给EAX\n\n```\nleave是汇编语言中用来关闭栈帧的指令名，通常用于函数末尾\n在16位汇编下相当于:\nmov sp,bp\npop bp\n \n在32位汇编下相当于:\nmov esp,ebp;\n//将ebp指向（ebp内部应当保存一个地址，所谓指向即这个地址对应的空间）的值赋给esp\npop ebp \n \n/* leave指令将EBP寄存器的内容复制到ESP寄存器中，\n以释放分配给该过程的所有堆栈空间。然后，它从堆栈恢复EBP寄存器的旧值。*/\nenter有时在函数开头，正好相反,相当于：\npush ebp\nmov ebp,esp\n\n```\n\n![图片](./pwn/pwn14.png)\nret 返回，把当前栈顶的值放入EIP，并且使栈顶指针加地址4默认，可以看到上面，esp储存的就是main函数内存地址\n代码块跳转变化：\n![图片](./pwn/pwn15.png)\n\n堆栈变化：\n![图片](./pwn/pwn16.png)\n\nadd    esp, 8   平衡堆栈，esp+8，就是esp地址下移动8字节，两行\n![图片](./pwn/pwn17.png)\n\nmov    dword ptr [ebp - 4], eax   又是把eax的数据转存到堆栈\nmov    eax, 0    把eax清零\nleave\n![图片](./pwn/pwn18.png)\n\nret 从main函数再返回就到结束阶段了，后面不解释\n![图片](./pwn/pwn19.png)\n\n\ndelete     最后删除所有断点 \n\n```\n掌握函数调用的流程，以及函数调用约定，\n就像今天的例子压入1，2，3，用高级语言进行汇编，所以压入栈内就是321了，\n了解栈的特性：先进后出。栈的生长方向 ，堆栈平衡的操作。\n要继续熟悉掌握汇编语言，会看x86的汇编指令，了解eflag标志寄存器的变化。\n了解掌握gdb调试（pwndbg，peda）的使用，和相关指令。\n```\n","tags":["PWN","01 PWN基础知识"],"categories":["PWN","01 PWN基础知识"]},{"title":"博客的搭建教程","url":"/2022/02/10/boke/","content":"点击文章标题进入阅读模式！\n\n前言：\n很荣幸这是我的第一篇私人博客，所以在我想些要准备用博客来干些什么，写些什么的时候，我决定先和大家分享一下我的私人博客是如何建立的，这也算个不错的优良记录和备份的习惯。\n\n大家如果有任何觉得我写的的不好的地方欢迎指出改进。可以再b站私信我\n\n链接[欢迎大家关注我的Bilibli](https://space.bilibili.com/2098810443)\n![思维导图](/assets/bk1.png)\n \n创建一个文件夹blog，这里面将放入你的博客文件\n\n# 环境搭建： \n1.\tnode.js\n浏览器上搜索node.is去官网点击下载安装包(.msi),根据自己的需求，我这里选择的是windows64位\n2.\tgit\n去git官网点击Download for Windows我选择的是64-bit Git for Windows Setup.\n3.\thexo\n在blog文件目录下鼠标右键打开Git Bash Here\n执行：npm config set registry http://registry.npm.taobao.org\n执行：npm install hexo-cli -g\n\n# 生成博客文件：\n  执行：hexo init\n\n# 预览博客文件：\n  执行：hexo s\n  此时可以复制搜索输出的网址，即可预览到自己的博客网页。\n  Ctrl+c\n# 部署到码云(gitee)平台：\n  首先到gitee网页点击右上角的加号，新建库，名字最好以自己的账户名命名，分支选择master,点击创建。\n  复制网页上这一条网址：在很显眼的位置，点击红色我框住的地方即可直接复制。\n ![图片](/assets/bk2.png)\n在blog文件夹下找到_config.yml文件，用记事本打开，找到最下方这个位置。\n在type:’’的单引号中输入git\n换行，空格，输入repo:空一格，粘贴上面复制的文件\n换行，输入branch: master\n ![图片](/assets/bk3.png)\n\n## 安装部署工具：npm install hexo-deployer-git –save\n\n## 生成静态文件：hexo g\n\n\n\n\n### 部署：hexo d\n  这时出现了用户需要用户的登录提示，否则会部署不成功会出现下面的这种情况：\n ![图片](/assets/bk4.png)\n  执行：git config –global user.name “你的用户名”\n  执行：git config -global user.email “你的邮箱”\n  然后就会弹出Windows安全中心的登录提示：这时候只需要输入你注册gitee时的邮箱，登录gitee的密码即可\n  执行：hexo d\n  这里其实部署的就是在blog文件下的public下的所有文件夹到远端分支\nGitee Pages 服务：\n  在网页部署的文件页面下，点击服务，点击gitee pages,这里要上传个人实名认证，一天通过后，就可以直接点击开启服务，稍等后出现一个网址，点击该网址，也可以跳转到我们的博客网页，但是在这里我遇到的问题就是打开后，只有文本字符，没有任何的图形界面。\n  \n  所以我又找到了SCDN的一位大佬：可可与鱼\n  [大佬传送门](https://blog.csdn.net/qq_40157728/article/details/114327987?ops_request_misc=&request_id=&biz_id=102&utm_term=Github%20pages%20%E6%8A%A5%E9%94%99404%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80_Keyu_lo&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-114327987.142^v10^pc_search_result_control_group,157^v4^control&spm=1018.2226.3001.4187)\n\n  所以我把权限改成了开源，而且github云端建立存放网页的repository时，命名为自己的gitee ID(例如：ID为xxx，则repository name 为xxx.gitee.io)。所以我就是把ID改了，改成和gitee.io前面的xxx一样的内容。这样再点击更新的网址连接图形界面就出来了。\n\n\n# 更换主题：\n  我们可以直接搜索hexo 主题\n  我们这里使用的是一个github上的主题：(GitHub - liuyib/hexo-theme-stun: 🦄 An elegant theme for Hexo)\n  在blog文件下的themes文件右键打开git bash here,\n  执行：git clone GitHub - liuyib/hexo-theme-stun: 🦄 An elegant theme for Hexo\n  就把主题下载进来了，然后我们就要修改配置，还是文本打开_config.yml\n  找到：\n ![图片](/assets/bk5.png)\n把theme: 后面修改成刚才下载的主题文件夹名称\n安装依赖：npm install –save hexo-renderer-pug\n预览新主题：hexo s\n生成新静态文件：hexo g\n重新部署：hexo d\n更新gitee pages服务\n  至此呢我们的个人博客差不多就算是搭建好了。\n","tags":["博客搭建","博客的搭建教程"],"categories":["博客搭建","博客的搭建教程"]},{"title":"Hello World","url":"/2021/07/10/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","tags":["博客搭建","hello-world"],"categories":["博客搭建","hello-world"]},{"title":"恺撒密码","url":"/2021/07/10/kaisa/","content":"\n\n点击文章标题进入阅读模式！\n\n尊重知识产权，引用注明出处！谢谢合作！\n有问题请在B站私信！\n链接[欢迎大家关注我的Bilibli](https://space.bilibili.com/2098810443)\n感谢一键三连哦~\n\n\n  在密码学中，恺撒密码（英语：Caesar cipher），或称恺撒加密、恺撒变换、变换加密，是一种最简单且最广为人知的加密技术。它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例如，当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推。这个加密方法是以罗马共和时期恺撒的名字命名的，当年恺撒曾用此方法与其将军们进行联系。\n\n这里我们主要讨论的还是如何使用C语言，和Python语言实现恺撒密码的算法！\n关于密码，具体还请看到百度百科解释[恺撒密码](https://baike.baidu.com/item/%E6%81%BA%E6%92%92%E5%AF%86%E7%A0%81/4905284)\n![图片](/kaisa/kaisa.jpg)\n\n\n（1）. 如何确定哪些字符不需要改变？哪些字符需要改变？如果需要改变？应该改为哪个对应的字符？\n\n算法的处理方法是：输入一个字符串，给字符变量char c，先判定它是否为字母（包括大小写）。若不是字母，则不改变c的值；若是字母则还要继续检查它是否在（‘Z’-密钥数字+1~’Z’）内（包括大小写字母也是对应转化）。如果不在这个范围，那么就可以正常偏移，即使该字母的ASCII值+密钥，这就等于字母往后移动了密钥的位数；如果在这个范围内，那么偏移是就该使该字母的ASCII值+密钥-26，因为有26个英文字母，所以减26就是回到A开始继续往后移动\n\n（2）. 如何使字符变量c改变为所指定的字母？\n\n办法是改变它的ASCII值，例如字符变量的原值使大写字母'A'，想使c的值改变为'E'，只需执行'c = c + 4'即可，因为'A'的ASCII值是65，而'E'的ASCII值是69，二者相差4。\n\n对照ASCII表\n![ASCII表](/kaisa/ASCII.jpg)\n\nC语言源程序代码：\n```c\n//凯撒密码\nint add()\n{\n\tchar a[20] = { 0 };\n\tint b = 0;\n\tint c = 0;\n\tprintf(\"输入密文：\\n\");\n\tscanf(\"%s\", a);\n\tc = strlen(a);\n\tprintf(\"输入密钥：\\n\");\n\tscanf(\"%d\", &b);\n\tfor (int i = 0; i < c; i++)\n\t{\n\t\tif ((a[i] >= 'a' && a[i] <= 'z') || (a[i] >= 'A' && a[1] <= 'Z'))\n\t\t{\n\t\t\tif ((a[i] >= ('Z' - b + 1) && a[i] <= 'Z') || (a[i] >= ('z' - b + 1) && a[i] <= 'z'))\n\t\t\t{\n\t\t\t\ta[i] = a[i] - (26 - b);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta[i] = a[i] + b;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tprintf(\"%c\", a[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\nint main() \n{\n\tadd(1);\n\tsystem(\"pause\");\n}\n```\n运行结果:\n![C](/kaisa/c.png)\n\n\npython代码实现\n```python\n# -*- coding = utf-8 -*-\n# @Time : 2022/5/8 22:04\n# @Author : 乙太\n# @file : 凯撒加密.py\n# @Software: PyCharm\n\nstr = input(\"输入密文：\\n\")\nb = int(input(\"输入密钥：\\n\"))\nflag=\"\"\nfor i in range (len(str)):\n    if (ord(str[i]) >= ord('a') and ord(str[i]) <= ord('z')) or (ord(str[i]) >= ord('A') and ord(str[1]) <= ord('Z')):\n        if ((ord(str[i]) >= (ord('Z') - b + 1) and ord(str[i]) <= ord('Z')) or (ord(str[i]) >= (ord('z') - b + 1) and ord(str[i]) <= ord('z'))):\n            flag += chr(ord(str[i]) - (26 - b))\n        else:\n           flag += chr(ord(str[i]) + b)\n    else:\n        flag += str[i]\nprint(flag)\n```\n运行结果:\n![py](/kaisa/py.png)\n","tags":["密码学","恺撒密码"],"categories":["密码学","恺撒密码"]},{"title":"程序脱壳篇","url":"/2021/07/10/ketu/","content":"点击文章标题进入阅读模式！\n\n尊重知识产权，引用注明出处！谢谢合作！\n有问题请在B站私信！\n链接[欢迎大家关注我的Bilibli](https://space.bilibili.com/2098810443)\n感谢一键三连哦~\n\n# 一· 什么是壳？\n\n## 1 . 初步认识壳\n\n历史：壳是最早出现的专用加密软件技术！\n\n作用：可以是开发者未来保护自己的代码不被借鉴、破解、逆向；也可用来病毒、木马、蠕虫隐藏恶意代码，不被杀毒如软件查杀！\n\n预习：vmp纯虚拟机壳，目前公认认为公认最强。\n\n温馨提示：脱壳上瘾，可不要随意传播哦!\n\n## 2 . 壳的执行过程\n\n加壳压缩，壳先执行，还原源程序，执行源程序\n\n## 3 . OEP(Original Entry Point)\n\n### 1·EP(Entry Point)\n\nEP(Entry Point)，意即程序的入口点。而OEP是程序的原始入口点，一个正常的程序只有EP，\n\n例如：C语言main函数、winAPI函数、VC编译的入口地址0x40000000\n\n只有入口点被修改的程序(加壳等)，才会拥有OEP。\n\n### 2·OEP\n\nOEP：(Original Entry Point)，程序的原始[入口点](https://baike.baidu.com/item/入口点)，软件加壳就是隐藏了EP， 只要我们找到程序的OEP，就可以立刻脱壳。\n\n [PUSHAD](https://baike.baidu.com/item/PUSHAD) （压栈） 代表程序的入口点，[POPAD](https://baike.baidu.com/item/POPAD) （出栈） 代表程序的出口点，与PUSHAD相对应，一般找到这个OEP就在附近啦。\n\n## 4 . 壳的装载过程\n\n模拟windows加载器：\n\n壳获取自己所需要使用的API地址、解压或解密源程序的各个区块、进行必要的重定位、跳转到程序原入口点（OPE）\n\n## 5 . 压缩引擎\n\n### 1·aPLib\n\n- [aPLib](http://www.ibsensoftware.com)\n\n低于64kb的文件压缩速度较快\n\n### 2·JCALG1\n\n- [JCALG1](http://www.bitsum.com/other)\n\n对大文件效果较好\n\n### 3·LZMA\n\n- [LZMA](http://www.7-zip.org/zh-cn/adk.html)\n\n使用目的：开源，稳定\n\n特点：保证压缩比的情况下解压速度一定要快\n\n## 6 . 壳的分类\n\n### 1·压缩壳\n\n- ASPack\n- UPX\n- PECompact\n\n### 2·加密壳\n\n- ASProtect\n- Armadillo\n- EXECryptor\n- Themida\n- VMProtect 缺点慢\n\n---\n\n# 二· 实践是检验真理的唯一标准\n\n接下来我们尝试破解这样一个老程序壳：![image](./ketu/p1.png)\n\n## 1 . 查看壳\n\n### 1·PEiD查看\n\n![image-20220413](./ketu/p2.png)\n\n### 2·Exeinfo PE查看\n\n![image-20220413](./ketu/p3.png)\n\n咳咳咳，咋就是说，这找不到这个程序壳的特征码，咋们看不出什么来，试试别的，是个老古董壳！\n\n### 3·脱壳后的程序查看\n\n![image](./ketu/p4.png)\n\n可见它是由VC5.0编译的程序！\n\n![image-20220413](./ketu/p5.png)\n\n可见无壳！\n\n## 2 . OD脱壳\n\n用od把程序打开，刚进来情况是这样的：\n\n![image-20220413](./ketu/p6.png)\n\n刚进来的时候是要提示是壳的EP，如果不是，要在选项/调制选项/事件中设置第一次暂停于主模块入口：\n\n![image-20220413](./ketu/p7.png)\n\n点击OD里面的M查看进程内存：\n\n![image-20220413](./ketu/p8.png)\n\n试着分析对比，可见代码的入口地址是0x00401000，按C回到查看汇编代码，我们现在的入口地址是0x46B6DE，可见它在包含SFX的地址0x46B00000中。这壳有这三个区块（资源、SFX、重定向）。.text段就是程序的代码段块！\n\n接下来单步执行F8，到jmp的时候跳转到地址0x004271B0:\n\n![image](./ketu/p9.png)\n\n来到这大概这个样子，右键分析/分分析代码：\n\n![image](./ketu/p10.png)\n\n再看进程内存，可知0x004271B0是在包含代码地址0x00401000中，所以它开头是55/8BEC，我们就找到了OEP\n\n在OD的plugin文件夹中加入插件重新打开：\n\n![image](./ketu/p11.png)\n\n右键选择插件dump debugged process把程序dump出来\n\n如下设置：\n\n![image](./ketu/p12.png)\n\n确保勾选Fix Raw Size是修复壳进行的数据偏移，不勾选Rebuil lmport输入表不进行重定位！\n\n点击dump，保存文件命名dumo1，回到上面脱壳后的查看！\n\n## 3 . 删除壳，减小程序大小\n\n目前查看dump1.exe文件属性/大小：\n\n![image](./ketu/p13.png)\n\n打开软件lordPE，然后点击PE Editor按钮，选择dump1，对照弹出窗口里面显示的出数据和OD里的进程内存对比，然后点击Sections按钮，发现多余的壳区块，通通右键选择wipe section header, 如果是灰色的，那么请确保程序先不处于运行状态。后点击Save按钮保存OK。\n\n![image-20220413224740751](./ketu/p14.png)\n\n最后点击Rebuild PE再选择dump1打开：\n\n![image-20220413224850649](./ketu/p15.png)\n\n咋就知道，程序大小最后变成了原本91%！\n\n![image-20220413225205230](./ketu/p16.png)\n\n此时再用OD打开就发现壳已经无了：\n\n![image-20220413225131666](./ketu/p17.png)\n\n\n\n\n\n## 4 . 根据堆栈平衡原理寻找OEP\n\n### 1·示例：zip压缩壳\n\n实例：看文件名可猜测这是一个压缩壳\n\n![image-20220414144957058](./ketu/p18.png)\n\n用OD打开，发现刚进来第一句就是一堆跳转之中的一个jmp:\n\n![image-20220414145244971](./ketu/p19.png)\n\n这里就是壳的模块入口了，F8执行，可见这格式像是VC程序的入口点：\n\n![image-20220414182834762](./ketu/p20.png)\n\n可是这并不是OEP，这是为什么呢？原因我们来到进程内存来看：\n\n![image-20220414183146139](./ketu/p21.png)\n\n程序目前运行地址在0x004682BC，这大概在进程内存的0x00465000到0x0046A000之间，并不是我们所想的在0x401000里面，所以它其实是一个伪造程序区块OEP的壳！\n\n现在我们重新打开，从最开始就要注意观察ESP寄存器的变化：\n\n刚开始是0012FFC4，当运行到![image-20220414191517674](./ketu/p22.png)\n\n时ESP发生第一次变化，变成0012FFC0，我们要把鼠标放在ESP显示的数据上右键选择数据窗口中跟随：\n\n![image-20220414212857900](./ketu/p23.png)\n\n然后就可以在数窗口看到0012FFC0，这是ESP所在的内存的位置，在该位置右键/断点/硬件访问/word都可以：\n\n![image-20220414213357003](./ketu/p24.png)\n\n此时就设置好了硬件断点，此断点不一般，只能在/调试/硬件断点/查看到哦，也可在此修改，也可以看到一般它只有四个硬件断点，使用的CPU特殊寄存器下断：\n\n![image-20220414213713220](./ketu/p25.png)\n\nF9直接运行到断点的位置![image-20220415101819043](./ketu/p26.png)\n\n此时ESP的值是0012FFC4，刚好是刚才断点的位置！\n\n这里可以记录一下，一般大部分的壳出现jmp eax都是跳转到OEP，但是这会出现一个明显的分界点，所以现在一些的强壳不会这样做！\n\n可以看到EAX的值是004271B0，我们继续看到进程内存，它在0x00401000到0x0044B000之间的代码区块！\n\n然后F8就进到了OEP:![image-20220415112909192](./ketu/p27.png)\n\n此时就可以删除硬件断点，并进行dump操作！\n\n也是先不勾选重定向，然后保存dump2!\n\n此时打开lordPE，点击PE Editor按钮，选择dump2打开：\n\n![image-20220415185618813](./ketu/p28.png)\n\n先点击Sections按钮把壳的区块删除。然后可以看到ImageBase:00040000正确。但是代码段的偏移Base0fCode:00065000指向的还是伪装壳的代码段，所以我们要把他修改偏移成1000，Base0fData:改成4B000。，Save，OK保存！![image-20220415201035557](./ketu/p29.png)\n\n会发现它脱完壳之后竟然变大了原来的85%，因为这是压缩壳！\n\n接下来就可以根据retn所指向链接的黑线找到该区块的入口：![image-20220415223054110](./ketu/p30.png)\n\n根据这个内存地址和连接指向的红线我们可以再往上寻找，发现就是回到了我们刚进来的一堆jmp的地方：![image-20220415223502317](./ketu/p31.png)\n\n也就是这样通过一连串的代码块的跳转对文件不同区块的压缩和加密！\n\n\n\n### 2·作业\n\n#### 1.eXPressor壳\n\n程序：![image-20220416103816878](./ketu/p32.png)\n\n查看PEiD:![image-20220416103859136](./ketu/p33.png)\n\n可见这是一个exPressor的壳！\n\nOD打开程序，刚进来就在这个地址：![image-20220416104054028](./ketu/p34.png)\n\n点击M查看进程内存：![image-20220416104212052](./ketu/p35.png)\n\n根据经验，程序本来的.text代码块被壳包含在了0x0046B000开始的区段，达到了“壳里有肉，肉里有壳”的效果！\n\n根据堆栈平衡原理(80%有效)找到OEP，这次进行dump操作的时候，一点要勾选上重定向输入表！![image-20220416104837596](./ketu/p36.png)\n\n这样插件就会搜索重建输入表，搜索里面的jmp跳转到一些API，然后再把这些API依次组成一个输入表！保存为dump3\n\n再用PEiD查看dump3.exe的时候，就原型毕露了，知道它是VC++5.0写的一个程序！\n\n再用OD打开dump3.exe点击M查看进程内存：\n\n![image-20220416105442548](./ketu/p37.png)\n\n发现它多了一个输入表！\n\n我们在进行LordPE的时候修改偏移Base0fcode的时候，首先要看到dump3程序入口点地址：![image-20220416105855396](./ketu/p38.png)\n\n对比上面的进程内存，可见他在0x401000开始的区段，所以Base0fcode要修改成1000！Save\n\n在删除多余的区块的时候，备份一份，尝试后发现，只有.ex_cod可以wipe掉！![image-20220416110735593](./ketu/p39.png)\n\n最后Rebuild PE选择dump3!![image-20220416111201710](./ketu/p40.png)\n\n完成！\n\n\n\n#### 2.MEW压缩壳\n\n程序：![image-20220416111513837](./ketu/p41.png)\n\n查看壳：![image-20220416111616682](./ketu/p42.png)\n\n这题只需要注意一点，像MEW系列壳除了可以使用堆栈平衡原理寻找OEP，记得分析代码；还可以在第一个区段网下滑找到retn加断点，F9运行到这F8,就到了OEP。应为这种壳，就是有个大区段，对软件进行解压缩，没有对它进行什么防护措施！\n\n其他的都很简单，直接ReBulid PE就行，不用删除什么区块！\n\n\n\n## 5 . .text区块加断点寻找OEP \n\n程序：![image-20220417165724224](./ketu/p43.png)\n\n查看壳：![image-20220417165927233](./ketu/p44.png)\n\n该程序直接点击运行是没有任何问题的，但是一用OD运行就只能运行出一个空窗口，而且这时使用堆栈平衡法寻找OEP也是不管用，所以这个程序是具有反调试系统的，所以我们之能先一步一步走，看能不能找到关于OD的API函数，直到运行到：\n\n![image-20220417171333489](./ketu/p45.png)\n\n![image-20220417171627417](./ketu/p46.png)\n\nIsDebuggerPresent是windows提供的对调试器判断的一个API\n\n还有一种更快捷的办法，右键/查找/所有模块中的名称/往下滑就能看到IsDebuggerPresent：![image-20220417174617927](./ketu/p47.png)\n\n双击就进了它的动态链接库：![image-20220417175339918](./ketu/p48.png)\n\n在这里我们加断点，运行到这，然后按Alt+F9也可以来到差不多我们刚才单步走到的位置！![image-20220417180734491](./ketu/p49.png)\n\n注意寄存器EAX，当能探测到调试器的时候eax=1，反之不能探测到则为eax=0\n\n因此可见，该程序跳转就不能是实现了：![image-20220417181116429](./ketu/p50.png)\n\n![image-20220417181138685](./ketu/p51.png)\n\n所以我们可以先修改，标准寄存器ZF位的值吧，也可以把它改为jmp，让其实现跳转，此时再按F9运行可见程序就能正常执行了！\n\n此时就是去掉他的反调试功能了，在修改jmp的位置此时右键/复制到可执行文件/选择，然后保存文件，命名2。\n\n继续用OD打开去掉反调试后的该文件2：![image-20220417220910299](./ketu/p52.png)\n\n查看进程内存：![image-20220417221014633](./ketu/p53.png)\n\n\n\n但是！后面发现，用堆栈平衡方式寻找OEP并没有用，甚至停不下！所以这里我们要用另外一种方法就是在.text区块加断点！因为壳不论怎么运行终究还是要回到源程序的代码段的，所以我们就直接在原程序代码段加断点：![image-20220417221621685](./ketu/p54.png)\n\n00401000右键/在访问上设置中断，运行：![image-20220417221947771](./ketu/p55.png)![image-20220417222117355](./ketu/p56.png)\n\n但是这并不是我们想要的地址，那由于运行过了，断点取消了，那我们再继续断继续走，多次后发现并不可以，但是我们看到了loopd:![image-20220417222350059](./ketu/p57.png)\n\n可以看到这里灰线的箭头其实是多次循环回去了，所以我们先直接先让它跳出循环再说，在循环外的下一个地址加断/运行/取段，就来到了这：![image-20220417222642877](./ketu/p58.png)\n\n此时再次00401000下断点/运行的时候，又是多次来到了这里：![image-20220417222921036](./ketu/p59.png)\n\n可见这是又有一个循环的，那总是进去很多个循环怎么办，一个一个像上面那样吗？不！我们重新开始，可以Ctrl+F8，或者长按F8，先观察循环都在哪里，再直接找到循环的末端，通过上面的方式下断：![image-20220417225402388](./ketu/p60.png)\n\n看就是这个灰色循环，目前我们已经断在外了，取断后，断00401000执行，然后我们就来到真实的OEP啦，右键/分析/分析代码：![image-20220417225655198](./ketu/p61.png)\n\n然后我们就把它dump5吧：![image-20220417225834904](./ketu/p62.png)\n\n接下来备份dump5就可以开始老的方法wipe去除多余的区块.Prt啦！\n图片 p120.png:\n\n![image-20220417230154503](./ketu/图片p120.png)\n\n成功啦！\n\n---\n\n\n\n# 三· 重建IAT输入表(Import Address Table)\n\n## 1 . 啥是输入表？\n\n在各种不同版本的Windows系统中，DLL的版本各不相同，同一函数在不同版本DLL中的位置也可能不同；另外一个原因在于DLL的重定位，DLL文件的ImageBase值一般为10000000，但当两个DLL尝试装载到同一个地址时会发生冲突，因此有一个DLL得寻找另一个地址装载，这就是所谓的DLL重定位。\n\n因此当我们要调用某个DLL中的函数时，需要借助IAT(Import Address Table，导入地址表）作为中间桥梁。PE文件在装载时由PE装载器将导入函数的真实地址写入到IAT时，函数调用时则需要从IAT中获取函数的真实地址。\n\n```c\n对于每一个引入的可执行文件（例如dll），有一个镜像引入描述符(IMAGE_IMPORT_DESCRIPTOR)。\ntypedef struct _IMAGE_IMPORT_DESCRIPTOR {\n     union {\n          DWORD Characteristics;         // 0 for terminating null import descriptor\n          DWORD OriginalFirstThunk;   // RVA to original unbound IAT (PIMAGE_THUNK_DATA)\n     };\n     DWORD TimeDateStamp;           // 0 if not bound,\n                                                                // -1 if bound, and real date\\time stamp\n                                                                // in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)\n                                                                // O.W. date/time stamp of DLL bound to (Old BIND)\n      DWORD ForwarderChain;           // -1 if no forwarders\n      DWORD Name;                             // RVA，指向字符串，是这个可执行文件的名字。例如\"ACE.dll\"\n      DWORD FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)\n} IMAGE_IMPORT_DESCRIPTOR;\n```\n\n```c\nIAT是一个IMAGE_THUNK_DATA类型的数组。有多少个函数被导入，这个数组就有多少个成员。该数组以0结尾。\ntypedef struct _IMAGE_THUNK_DATA32 {\n     union {\n           DWORD ForwarderString;          // 一个RVA地址，指向forwarder string \n           DWORD Function;                       // PDWORD，被导入的函数的入口地址\n           DWORD Ordinal;                         // 该函数的序数\n           DWORD AddressOfData;           // 一个RVA地址，指向IMAGE_IMPORT_BY_NAME\n      } u1;\n} IMAGE_THUNK_DATA32;\n```\n\n```c\nPIMAGE_IMPORT_BY_NAME是一个非常简单的结构，就两个成员。\ntypedef struct _IMAGE_IMPORT_BY_NAME {\n     WORD Hint;            // 该函数的导出序数\n     BYTE Name[1];      // 该函数的名字\n} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;\n```\n\n![image-20220418162411370](./ketu/p63.png)\n\n## 2 . OD跟踪输入表\n\n例程序：![image-20220418163214018](./ketu/p64.png)\n\n这是个简单的MessgeBoxA对话框程序，用OD打开：![image-20220418163346289](./ketu/p65.png)\n\n虽然OD注释可以识别到这是MessgeBox，但点开这条指令是call 004011EA，那为什么它知道内存地址0x004011EA地址是一个MessgeBoxA的API函数呢？\n\n那我们就在这行按下回车Enter键：![image-20220418164053565](./ketu/p66.png)\n\n可以看到这是个跳转，其实周围还很多都是跳转，查看下面按是跳转到哪里：![image-20220418164207582](./ketu/p67.png)\n\n上面显示的是取[00402048]内存地址里面的值=77D507EA跳转，为了验证一下，我们在内存窗口Ctrl+G输入00402048，就来到了这个地址：![image-20220418164606243](./ketu/p68.png)\n\n根据小端存储，从右往左读，发现正是77D507EA!\n\n所以我们可以知道在这整个程序无论到在个位置调用MessgeBoxA，它都相当于call 004011EA，在这里集中跳转到MessgeBoxA的动态链接库！![image-20220418170825475](./ketu/p69.png)\n\n可以看到上面这些都是OD分析给我的，但是OD为什么会知道呢，其实就是根据IAT得出的！\n\n接下来我们继续跟踪输入表，Alt+M到内存双击PE文件头，也就是00400000区块：\n\n然后我们就可以看到标准PE头文件格式：![image-20220418173633788](./ketu/p70.png)标志：![image-20220418173706834](./ketu/p71.png)Image Base：![image-20220418173758790](./ketu/p72.png)偏移地址，这是输入表的地址Import Table address：![image-20220418173909910](./ketu/p73.png)\n\n回到内存窗口，其实输入表所在地差不多就在这个位置：![image-20220418174153805](./ketu/p74.png)\n\n接下来我们在代码窗口Ctrl+G搜索00402050，我们就来到了这里，但是发现没办法分析，因为它认为我们这不是在代码段：![image-20220418174515314](./ketu/p75.png)\n\n所以我们要像之前一样安装一个新的插件：![image-20220418174706485](./ketu/p76.png)\n\n安装好插件后重新打开，就可以点击Analyze This!![image-20220418175424943](./ketu/p77.png)\n\n可见左边黑色数据是小端存储，右边绿色是OD简化成了我们方便阅读的字节形式，都是相对400000的偏移地址，可见总共有两个IMAGE_IMPORT_DESCRIPTOR，最后一个全是0是作为结束的标识。我们先尝试Ctrl+G搜第一个参数OriginalFilrstThunk地址00402098：![image-20220418180222534](./ketu/p78.png)\n\n然后就走到了INT的第一个参数IMACE_THUNK_DATA又是一个偏移地址00402122，继续搜：![image-20220418180509903](./ketu/p79.png)\n\n可见我们就来到了IMAGE_IMPORT_BY_NAME内，可找到函数的名字（都是由ASCII码转换翻译的）！\n\n然后看到IMAGE_IMPORT_DESCRIPTOR第五个参数FirstThunk，这才是真正指向IAT的偏移地址：![image-20220418181002394](./ketu/p80.png)\n\n搜索到：![image-20220418181113132](./ketu/p81.png)\n\n可见其实这就是IAT输入表！\n\n\n\n## 3 . HOOK-API\n\n壳为了防止输入表被还原，强化壳自身的保护功能，会在IAT大量加密。\n\n例如：源程序要调用一个函数的时候需要找IAT，然后却进到了壳程序进行监控般的跳转才能最终回到IAT!\n\n\n\n---\n\n\n\n# 四· FSG压缩壳和ImportREC的使用\n\n程序可以正常运行：![image-20220418184914873](./ketu/p82.png)\n\n查看壳：![image-20220418184815948](./ketu/p83.png)\n\n可见这是用Delphi7.0写的程序，API比较多，所以IAT修复比较麻烦！\n\n安装壳程序，点击install.exe,或者自行解压fsg.rar：![image-20220418185939919](./ketu/p84.png)\n\n给程序FishC加壳，拖拽即可！这是一个压缩壳，压缩44%![image-20220418202739825](./ketu/p85.png)加壳后程序也可正常运行！\n\n现在查看壳就可看到壳了：![image-20220418203113866](./ketu/p86.png)\n\n把加FSG壳后的程序用OD打开:![image-20220418203704260](./ketu/p87.png)\n\n此时用老方法较为复杂，目前使用一种新方法，步骤如上图1234，选项/调试选项/SFX/字节方式跟踪真正入口处/重新运行！\n\n在这之后，还是回到了原来的地方，然后再带点击选项/调试选项/SFX/停在自解压器的入口/重新运行/，就可以看见左下角在疯狂的运行，这是在模拟程序的运行，自解压：![image-20220418204434819](./ketu/p88.png)\n\n然后就来到了OEP，接下来就是右键/分析/从模块中删除分析：![image-20220418204709439](./ketu/p89.png)\n\n接下来就可以dump操作了。由于SFG壳破坏了IAT，所以不要勾选重建输入表，因为勾选了也没用！我们接下来还要借助ImpREC.exe神奇工具修复IAT!\n\n![image-20220418214958019](./ketu/p90.png)\n\n如图，要确保要修改的程序被OD打开中或者与运行中，ImpREC才能检测到，然后根据我们刚才跟踪到了SFX代码真正入口点的地址，提取偏移地址，修改上面红色框起来的OEP，然后点击IAT AutoSearch就弹出一个提示框：![image-20220418215506236](./ketu/p91.png)\n\nImportREC会自动搜索所有的IAT!\n\n翻译：好像找到了一些东西，但也有可能不不正确，如果不正确，建议把RAV改成：00001000 Size改成：00094000\n\n接下俩我们就来验证一下，在内存搜索RAV地址，看它是不是IAT的入口点：![image-20220418220105690](./ketu/p92.png)\n\n就看到这里：![image-20220418220743104](./ketu/p93.png)\n\n继续往下滑就可以看见熟悉的API函数：![image-20220418220842333](./ketu/p94.png)\n\n可见00461BEC上面还包含一些数据其实也是，所以我们还要是要把RVA改成：0046B12C，把这些数据包含进去，这才能确保我们的IAT修复的是完整的，才能正常打开程序！\n\n可见IAT最后到了这里：![image-20220418221448148](./ketu/p95.png)\n\n所以Size也要修改，范围大了可以，范围小了就不可以，只要把全部IAT包含到了就可以！我们修改成大概10000吧：![image-20220418221928933](./ketu/p96.png)\n\n然后我们就可以点击Get Imports按钮了！\n\n加载一会儿，可以看到很多的valid:NO这些就都是不合法的，总共有6642条都是不合法：![image-20220418222316652](./ketu/p97.png)\n\n所以我们点击Show Invalid按钮把不合法的都展示出来，可见这些不合法的数据穿插在各个IAT里面，只要程序加载到这里的时候，加载不到，就会报错！所以我们右键/Cut thunk(s)，把这些不合法的东西全部都给砍掉！![image-20220418222733408](./ketu/p98.png)\n\n然后就可见我们见到的都是valid:YES的了，然后我们就点击Fix Dump按钮，选择覆盖刚才OD的dump文件：![image-20220418222951970](./ketu/p99.png)\n\n然后它就帮我们多生成了一个文件dump_可以正常运行！\n\n然后再用PEiD查看壳，如果有时候查看不出来![image-20220418223541715](./ketu/p100.png)可以选择选项/深度扫描：![image-20220418223618570](./ketu/p101.png)\n\n就出来了！也可以观察到，脱壳后的文件变大了！\n\n\n\n---\n\n\n\n# 五 . UPX和WinUpacx压缩壳\n\n[UPX官网](http://upx.sourceforge.net)\n\nUPX壳是目前最流行的，最稳定的壳，更新也较块！\n\n## 1 . upx309w命令行加\\脱壳\n\n![image-20220419090226751](./ketu/p102.png)\n\nwin+R打开控制台，cd到壳程序目录下，upx.exe加壳，后面的才参数是我们待加壳地程序，加壳后可以看到，压缩到了原来的51.93%，大小从582656变成了302592字节！\n\n其实也可以不用命令行，直接拖拽到upx.exe加壳！\n\n然后我们就能查到壳：![image-20220419090621346](./ketu/p103.png)\n\n然后查阅文档可知，命令加上-d参数，即可脱壳：![image-20220419091006607](./ketu/p104.png)\n\n如下：![image-20220419091127168](./ketu/p105.png)\n\n## 2 . Free UPX\n\n![image-20220419104644009](./ketu/p106.png)\n\n点击Add files按钮选择程序，COMPRESS是加壳，DECOMPRESS脱壳，下面的Backup file可以选择create可以创建一个副本，备份原程序！\n\n## 3 . OD脱UPX壳\n\nOD打开加UPX壳后的fishc程序:![image-20220419111142757](./ketu/p107.png)\n\n通过堆栈平衡原理寻找OEP过程中，硬件断点来到这里:![image-20220419111400944](./ketu/p108.png)\n\n由于这是3.09的版本壳，在之前的版本有可能是jmp，但这里jmp在下面，所以我们先取消硬件断点，然后在下面的jmp加断点/运行至此/去掉断点/F8/分析/分析代码，就来到了OEP:![image-20220419111758641](./ketu/p109.png)![image-20220419111850970](./ketu/p110.png)\n\n然后dump操作，注意不要勾选重建输入表，接下来我们要用ImportRE恢复！\n\n## 5 . 使用ImportREC修复IAT\n\n![image-20220419114356233](./ketu/p111.png)\n\n1. 先点击小三角选择用OD正在运行的原程序文件\n2. 更具OD找到的OEP，修改ImportREC的OEP里面的偏移地址\n3. 点击IAT AutoSearch按钮确定\n4. 根据给出的RAV偏移地址去OD内存搜索验证，保证输入表没被修改，如果被修改了，就要把RAV的偏移地址调整过来，把IAT包含进去！这里可见上滑上面没有了，是可以的准确的，下面的Size也把IAT包含了，OK![image-20220419115822595](./ketu/p112.png)\n5. 点击Get Imports按钮，点击Show Invalid按钮，可见没有错误的IAT![image-20220419120253262](./ketu/p113.png)\n6. 就可以直接Fix Dump选择刚才OD的dumpupx文件了！\n\n\n\n## 6 . WinUpacx壳\n\n该壳压缩效率更高，但已不更新！\n\n![image-20220419123029712](./ketu/p114.png)\n\n界面中文，比较友好！建议勾选3.清除导出表/4.清除重定位表\n\n然后压缩之后会出现一个文件：![image-20220419123200002](./ketu/p115.png)这个文件去掉.bak后缀之后就是我们的原程序备份！\n\n然后OD打开：![image-20220419124124354](./ketu/p116.png)\n\n入过一开始不是这里，那也可以Alt+M，双击fishc在数据窗口找到偏移地址，即可搜索：![image-20220419124349123](./ketu/p117.png)\n\n接下来就是根据堆栈平衡寻找OEP:![image-20220419124602886](./ketu/p118.png)\n\n就可进行dump操作，由于输入表已被破坏所以记得不用勾选重建，重建也是错误的!\n\n然后其实和上一个程序一样操作ImportREC，不多赘述！\n\n然后如果还不满意可以再进行LordPE操作：![image-20220419125328317](./ketu/p119.png)\n\n最后这就就完美啦！恭喜结业！！！芜湖！！！\n\n\n\n\n\n链接[欢迎大家关注我的Bilibli](https://space.bilibili.com/2098810443)\n感谢一键三连哦~\n---\n\n","tags":["程序壳","程序脱壳篇"],"categories":["程序壳","程序脱壳篇"]}]